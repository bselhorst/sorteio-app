"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.patchAdapter = patchAdapter;
exports.restoreAdapter = restoreAdapter;
exports.serveFile = serveFile;

var socket_io_adapter_1 = require("socket.io-adapter");

var fs_1 = require("fs");

var debug_1 = __importDefault(require("debug"));

var debug = (0, debug_1["default"])("socket.io:adapter-uws");
var SEPARATOR = "\x1f"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

var _socket_io_adapter_1$ = socket_io_adapter_1.Adapter.prototype,
    addAll = _socket_io_adapter_1$.addAll,
    del = _socket_io_adapter_1$.del,
    broadcast = _socket_io_adapter_1$.broadcast;

function patchAdapter(app
/* : TemplatedApp */
) {
  socket_io_adapter_1.Adapter.prototype.addAll = function (id, rooms) {
    var _this = this;

    var isNew = !this.sids.has(id);
    addAll.call(this, id, rooms);

    var socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);

    if (!socket) {
      return;
    }

    if (socket.conn.transport.name === "websocket") {
      subscribe(this.nsp.name, socket, isNew, rooms);
      return;
    }

    if (isNew) {
      socket.conn.on("upgrade", function () {
        var rooms = _this.sids.get(id);

        if (rooms) {
          subscribe(_this.nsp.name, socket, isNew, rooms);
        }
      });
    }
  };

  socket_io_adapter_1.Adapter.prototype.del = function (id, room) {
    del.call(this, id, room);

    var socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);

    if (socket && socket.conn.transport.name === "websocket") {
      // @ts-ignore
      var sessionId = socket.conn.id; // @ts-ignore

      var websocket = socket.conn.transport.socket;
      var topic = "".concat(this.nsp.name).concat(SEPARATOR).concat(room);
      debug("unsubscribe connection %s from topic %s", sessionId, topic);
      websocket.unsubscribe(topic);
    }
  };

  socket_io_adapter_1.Adapter.prototype.broadcast = function (packet, opts) {
    var useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;

    if (!useFastPublish) {
      broadcast.call(this, packet, opts);
      return;
    }

    var flags = opts.flags || {};
    var basePacketOpts = {
      preEncoded: true,
      "volatile": flags["volatile"],
      compress: flags.compress
    };
    packet.nsp = this.nsp.name;
    var encodedPackets = this.encoder.encode(packet);
    var topic = opts.rooms.size === 0 ? this.nsp.name : "".concat(this.nsp.name).concat(SEPARATOR).concat(opts.rooms.keys().next().value);
    debug("fast publish to %s", topic); // fast publish for clients connected with WebSocket

    encodedPackets.forEach(function (encodedPacket) {
      var isBinary = typeof encodedPacket !== "string"; // "4" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol

      app.publish(topic, isBinary ? encodedPacket : "4" + encodedPacket, isBinary);
    });
    this.apply(opts, function (socket) {
      if (socket.conn.transport.name !== "websocket") {
        // classic publish for clients connected with HTTP long-polling
        socket.client.writeToEngine(encodedPackets, basePacketOpts);
      }
    });
  };
}

function subscribe(namespaceName, socket, isNew, rooms) {
  // @ts-ignore
  var sessionId = socket.conn.id; // @ts-ignore

  var websocket = socket.conn.transport.socket;

  if (isNew) {
    debug("subscribe connection %s to topic %s", sessionId, namespaceName);
    websocket.subscribe(namespaceName);
  }

  rooms.forEach(function (room) {
    var topic = "".concat(namespaceName).concat(SEPARATOR).concat(room); // '#' can be used as wildcard

    debug("subscribe connection %s to topic %s", sessionId, topic);
    websocket.subscribe(topic);
  });
}

function restoreAdapter() {
  socket_io_adapter_1.Adapter.prototype.addAll = addAll;
  socket_io_adapter_1.Adapter.prototype.del = del;
  socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
}

var toArrayBuffer = function toArrayBuffer(buffer) {
  var arrayBuffer = buffer.buffer,
      byteOffset = buffer.byteOffset,
      byteLength = buffer.byteLength;
  return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
}; // imported from https://github.com/kolodziejczak-sz/uwebsocket-serve


function serveFile(res
/* : HttpResponse */
, filepath) {
  var _ref = (0, fs_1.statSync)(filepath),
      size = _ref.size;

  var readStream = (0, fs_1.createReadStream)(filepath);

  var destroyReadStream = function destroyReadStream() {
    return !readStream.destroyed && readStream.destroy();
  };

  var onError = function onError(error) {
    destroyReadStream();
    throw error;
  };

  var onDataChunk = function onDataChunk(chunk) {
    var arrayBufferChunk = toArrayBuffer(chunk);
    res.cork(function () {
      var lastOffset = res.getWriteOffset();

      var _res$tryEnd = res.tryEnd(arrayBufferChunk, size),
          _res$tryEnd2 = _slicedToArray(_res$tryEnd, 2),
          ok = _res$tryEnd2[0],
          done = _res$tryEnd2[1];

      if (!done && !ok) {
        readStream.pause();
        res.onWritable(function (offset) {
          var _res$tryEnd3 = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size),
              _res$tryEnd4 = _slicedToArray(_res$tryEnd3, 2),
              ok = _res$tryEnd4[0],
              done = _res$tryEnd4[1];

          if (!done && ok) {
            readStream.resume();
          }

          return ok;
        });
      }
    });
  };

  res.onAborted(destroyReadStream);
  readStream.on("data", onDataChunk).on("error", onError).on("end", destroyReadStream);
}
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParentNamespace = void 0;

var namespace_1 = require("./namespace");

var socket_io_adapter_1 = require("socket.io-adapter");

var debug_1 = __importDefault(require("debug"));

var debug = (0, debug_1["default"])("socket.io:parent-namespace");
/**
 * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either
 * with a regular expression or with a function.
 *
 * @example
 * const parentNamespace = io.of(/\/dynamic-\d+/);
 *
 * parentNamespace.on("connection", (socket) => {
 *   const childNamespace = socket.nsp;
 * }
 *
 * // will reach all the clients that are in one of the child namespaces, like "/dynamic-101"
 * parentNamespace.emit("hello", "world");
 *
 */

var ParentNamespace =
/*#__PURE__*/
function (_namespace_1$Namespac) {
  _inherits(ParentNamespace, _namespace_1$Namespac);

  function ParentNamespace(server) {
    var _this;

    _classCallCheck(this, ParentNamespace);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ParentNamespace).call(this, server, "/_" + ParentNamespace.count++));
    _this.children = new Set();
    return _this;
  }
  /**
   * @private
   */


  _createClass(ParentNamespace, [{
    key: "_initAdapter",
    value: function _initAdapter() {
      this.adapter = new ParentBroadcastAdapter(this);
    }
  }, {
    key: "emit",
    value: function emit(ev) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.children.forEach(function (nsp) {
        nsp.emit.apply(nsp, [ev].concat(args));
      });
      return true;
    }
  }, {
    key: "createChild",
    value: function createChild(name) {
      var _this2 = this;

      debug("creating child namespace %s", name);
      var namespace = new namespace_1.Namespace(this.server, name);
      this["_fns"].forEach(function (fn) {
        return namespace.use(fn);
      });
      this.listeners("connect").forEach(function (listener) {
        return namespace.on("connect", listener);
      });
      this.listeners("connection").forEach(function (listener) {
        return namespace.on("connection", listener);
      });
      this.children.add(namespace);

      if (this.server._opts.cleanupEmptyChildNamespaces) {
        var remove = namespace._remove;

        namespace._remove = function (socket) {
          remove.call(namespace, socket);

          if (namespace.sockets.size === 0) {
            debug("closing child namespace %s", name);
            namespace.adapter.close();

            _this2.server._nsps["delete"](namespace.name);

            _this2.children["delete"](namespace);
          }
        };
      }

      this.server._nsps.set(name, namespace); // @ts-ignore


      this.server.sockets.emitReserved("new_namespace", namespace);
      return namespace;
    }
  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the
      // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but
      // the behavior for namespaces created with a function is less clear
      // noteÂ²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace
      // may exist on one node but not exist on another (since it is created upon client connection)
      throw new Error("fetchSockets() is not supported on parent namespaces");
    }
  }]);

  return ParentNamespace;
}(namespace_1.Namespace);

exports.ParentNamespace = ParentNamespace;
ParentNamespace.count = 0;
/**
 * A dummy adapter that only supports broadcasting to child (concrete) namespaces.
 * @private file
 */

var ParentBroadcastAdapter =
/*#__PURE__*/
function (_socket_io_adapter_1$) {
  _inherits(ParentBroadcastAdapter, _socket_io_adapter_1$);

  function ParentBroadcastAdapter() {
    _classCallCheck(this, ParentBroadcastAdapter);

    return _possibleConstructorReturn(this, _getPrototypeOf(ParentBroadcastAdapter).apply(this, arguments));
  }

  _createClass(ParentBroadcastAdapter, [{
    key: "broadcast",
    value: function broadcast(packet, opts) {
      this.nsp.children.forEach(function (nsp) {
        nsp.adapter.broadcast(packet, opts);
      });
    }
  }]);

  return ParentBroadcastAdapter;
}(socket_io_adapter_1.Adapter);
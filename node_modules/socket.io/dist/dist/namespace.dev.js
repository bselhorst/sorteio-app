"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Namespace = exports.RESERVED_EVENTS = void 0;

var socket_1 = require("./socket");

var typed_events_1 = require("./typed-events");

var debug_1 = __importDefault(require("debug"));

var broadcast_operator_1 = require("./broadcast-operator");

var debug = (0, debug_1["default"])("socket.io:namespace");
exports.RESERVED_EVENTS = new Set(["connect", "connection", "new_namespace"]);
/**
 * A Namespace is a communication channel that allows you to split the logic of your application over a single shared
 * connection.
 *
 * Each namespace has its own:
 *
 * - event handlers
 *
 * ```
 * io.of("/orders").on("connection", (socket) => {
 *   socket.on("order:list", () => {});
 *   socket.on("order:create", () => {});
 * });
 *
 * io.of("/users").on("connection", (socket) => {
 *   socket.on("user:list", () => {});
 * });
 * ```
 *
 * - rooms
 *
 * ```
 * const orderNamespace = io.of("/orders");
 *
 * orderNamespace.on("connection", (socket) => {
 *   socket.join("room1");
 *   orderNamespace.to("room1").emit("hello");
 * });
 *
 * const userNamespace = io.of("/users");
 *
 * userNamespace.on("connection", (socket) => {
 *   socket.join("room1"); // distinct from the room in the "orders" namespace
 *   userNamespace.to("room1").emit("holà");
 * });
 * ```
 *
 * - middlewares
 *
 * ```
 * const orderNamespace = io.of("/orders");
 *
 * orderNamespace.use((socket, next) => {
 *   // ensure the socket has access to the "orders" namespace
 * });
 *
 * const userNamespace = io.of("/users");
 *
 * userNamespace.use((socket, next) => {
 *   // ensure the socket has access to the "users" namespace
 * });
 * ```
 */

var Namespace =
/*#__PURE__*/
function (_typed_events_1$Stric) {
  _inherits(Namespace, _typed_events_1$Stric);

  /**
   * Namespace constructor.
   *
   * @param server instance
   * @param name
   */
  function Namespace(server, name) {
    var _this;

    _classCallCheck(this, Namespace);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Namespace).call(this));
    /**
     * A map of currently connected sockets.
     */

    _this.sockets = new Map();
    /**
     * A map of currently connecting sockets.
     */

    _this._preConnectSockets = new Map();
    _this._fns = [];
    /** @private */

    _this._ids = 0;
    _this.server = server;
    _this.name = name;

    _this._initAdapter();

    return _this;
  }
  /**
   * Initializes the `Adapter` for this nsp.
   * Run upon changing adapter by `Server#adapter`
   * in addition to the constructor.
   *
   * @private
   */


  _createClass(Namespace, [{
    key: "_initAdapter",
    value: function _initAdapter() {
      // @ts-ignore
      this.adapter = new (this.server.adapter())(this);
    }
    /**
     * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.use((socket, next) => {
     *   // ...
     *   next();
     * });
     *
     * @param fn - the middleware function
     */

  }, {
    key: "use",
    value: function use(fn) {
      this._fns.push(fn);

      return this;
    }
    /**
     * Executes the middleware for an incoming client.
     *
     * @param socket - the socket that will get added
     * @param fn - last fn call in the middleware
     * @private
     */

  }, {
    key: "run",
    value: function run(socket, fn) {
      if (!this._fns.length) return fn();

      var fns = this._fns.slice(0);

      function run(i) {
        fns[i](socket, function (err) {
          // upon error, short-circuit
          if (err) return fn(err); // if no middleware left, summon callback

          if (!fns[i + 1]) return fn(); // go on to next

          run(i + 1);
        });
      }

      run(0);
    }
    /**
     * Targets a room when emitting.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // the “foo” event will be broadcast to all connected clients in the “room-101” room
     * myNamespace.to("room-101").emit("foo", "bar");
     *
     * // with an array of rooms (a client will be notified at most once)
     * myNamespace.to(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * myNamespace.to("room-101").to("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */

  }, {
    key: "to",
    value: function to(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // disconnect all clients in the "room-101" room
     * myNamespace.in("room-101").disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */

  }, {
    key: "in",
    value: function _in(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter)["in"](room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     * myNamespace.except("room-101").emit("foo", "bar");
     *
     * // with an array of rooms
     * myNamespace.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * myNamespace.except("room-101").except("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */

  }, {
    key: "except",
    value: function except(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
    }
    /**
     * Adds a new client.
     *
     * @return {Socket}
     * @private
     */

  }, {
    key: "_add",
    value: function _add(client, auth, fn) {
      var _this2 = this;

      var _a, socket;

      return regeneratorRuntime.async(function _add$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              debug("adding socket to nsp %s", this.name);
              _context.next = 3;
              return regeneratorRuntime.awrap(this._createSocket(client, auth));

            case 3:
              socket = _context.sent;

              this._preConnectSockets.set(socket.id, socket);

              if (!( // @ts-ignore
              ((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) && socket.recovered && client.conn.readyState === "open")) {
                _context.next = 7;
                break;
              }

              return _context.abrupt("return", this._doConnect(socket, fn));

            case 7:
              this.run(socket, function (err) {
                process.nextTick(function () {
                  if ("open" !== client.conn.readyState) {
                    debug("next called after client was closed - ignoring socket");

                    socket._cleanup();

                    return;
                  }

                  if (err) {
                    debug("middleware error, sending CONNECT_ERROR packet to the client");

                    socket._cleanup();

                    if (client.conn.protocol === 3) {
                      return socket._error(err.data || err.message);
                    } else {
                      return socket._error({
                        message: err.message,
                        data: err.data
                      });
                    }
                  }

                  _this2._doConnect(socket, fn);
                });
              });

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_createSocket",
    value: function _createSocket(client, auth) {
      var sessionId, offset, session;
      return regeneratorRuntime.async(function _createSocket$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              sessionId = auth.pid;
              offset = auth.offset;

              if (!( // @ts-ignore
              this.server.opts.connectionStateRecovery && typeof sessionId === "string" && typeof offset === "string")) {
                _context2.next = 15;
                break;
              }

              _context2.prev = 3;
              _context2.next = 6;
              return regeneratorRuntime.awrap(this.adapter.restoreSession(sessionId, offset));

            case 6:
              session = _context2.sent;
              _context2.next = 12;
              break;

            case 9:
              _context2.prev = 9;
              _context2.t0 = _context2["catch"](3);
              debug("error while restoring session: %s", _context2.t0);

            case 12:
              if (!session) {
                _context2.next = 15;
                break;
              }

              debug("connection state recovered for sid %s", session.sid);
              return _context2.abrupt("return", new socket_1.Socket(this, client, auth, session));

            case 15:
              return _context2.abrupt("return", new socket_1.Socket(this, client, auth));

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[3, 9]]);
    }
  }, {
    key: "_doConnect",
    value: function _doConnect(socket, fn) {
      this._preConnectSockets["delete"](socket.id);

      this.sockets.set(socket.id, socket); // it's paramount that the internal `onconnect` logic
      // fires before user-set events to prevent state order
      // violations (such as a disconnection before the connection
      // logic is complete)

      socket._onconnect();

      if (fn) fn(socket); // fire user-set events

      this.emitReserved("connect", socket);
      this.emitReserved("connection", socket);
    }
    /**
     * Removes a client. Called by each `Socket`.
     *
     * @private
     */

  }, {
    key: "_remove",
    value: function _remove(socket) {
      this.sockets["delete"](socket.id) || this._preConnectSockets["delete"](socket.id);
    }
    /**
     * Emits to all connected clients.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * myNamespace.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the clients
     * myNamespace.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @return Always true
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      var _ref;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_ref = new broadcast_operator_1.BroadcastOperator(this.adapter)).emit.apply(_ref, [ev].concat(args));
    }
    /**
     * Sends a `message` event to all clients.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.send("hello");
     *
     * // this is equivalent to
     * myNamespace.emit("message", "hello");
     *
     * @return self
     */

  }, {
    key: "send",
    value: function send() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
      // if you specify the EmitEvents, the type of args will be never.
      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.
     *
     * @return self
     */

  }, {
    key: "write",
    value: function write() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
      // if you specify the EmitEvents, the type of args will be never.
      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Sends a message to the other Socket.IO servers of the cluster.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.serverSideEmit("hello", "world");
     *
     * myNamespace.on("hello", (arg1) => {
     *   console.log(arg1); // prints "world"
     * });
     *
     * // acknowledgements (without binary content) are supported too:
     * myNamespace.serverSideEmit("ping", (err, responses) => {
     *  if (err) {
     *     // some servers did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per server (except the current one)
     *   }
     * });
     *
     * myNamespace.on("ping", (cb) => {
     *   cb("pong");
     * });
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     */

  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(ev) {
      if (exports.RESERVED_EVENTS.has(ev)) {
        throw new Error("\"".concat(String(ev), "\" is a reserved event name"));
      }

      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      args.unshift(ev);
      this.adapter.serverSideEmit(args);
      return true;
    }
    /**
     * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * try {
     *   const responses = await myNamespace.serverSideEmitWithAck("ping");
     *   console.log(responses); // one response per server (except the current one)
     * } catch (e) {
     *   // some servers did not acknowledge the event in the given delay
     * }
     *
     * @param ev - the event name
     * @param args - an array of arguments
     *
     * @return a Promise that will be fulfilled when all servers have acknowledged the event
     */

  }, {
    key: "serverSideEmitWithAck",
    value: function serverSideEmitWithAck(ev) {
      var _this3 = this;

      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }

      return new Promise(function (resolve, reject) {
        args.push(function (err, responses) {
          if (err) {
            err.responses = responses;
            return reject(err);
          } else {
            return resolve(responses);
          }
        });

        _this3.serverSideEmit.apply(_this3, [ev].concat(args));
      });
    }
    /**
     * Called when a packet is received from another Socket.IO server
     *
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     *
     * @private
     */

  }, {
    key: "_onServerSideEmit",
    value: function _onServerSideEmit(args) {
      _get(_getPrototypeOf(Namespace.prototype), "emitUntyped", this).apply(this, args);
    }
    /**
     * Gets a list of clients.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or
     * {@link Namespace#fetchSockets} instead.
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(_compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.volatile.emit("hello"); // the clients may or may not receive it
     *
     * @return self
     */

  }, {
    key: "timeout",

    /**
     * Adds a timeout in milliseconds for the next operation.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * myNamespace.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    value: function timeout(_timeout) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(_timeout);
    }
    /**
     * Returns the matching socket instances.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // return all Socket instances
     * const sockets = await myNamespace.fetchSockets();
     *
     * // return all Socket instances in the "room1" room
     * const sockets = await myNamespace.in("room1").fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit("hello");
     *   socket.join("room1");
     *   socket.leave("room2");
     *   socket.disconnect();
     * }
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // make all socket instances join the "room1" room
     * myNamespace.socketsJoin("room1");
     *
     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
     * myNamespace.in("room1").socketsJoin(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // make all socket instances leave the "room1" room
     * myNamespace.socketsLeave("room1");
     *
     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
     * myNamespace.in("room1").socketsLeave(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * myNamespace.disconnectSockets();
     *
     * // make all socket instances in the "room1" room disconnect and close the underlying connections
     * myNamespace.in("room1").disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
    }
  }, {
    key: "volatile",
    get: function get() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter)["volatile"];
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * const myNamespace = io.of("/my-namespace");
     *
     * // the “foo” event will be broadcast to all connected clients on this node
     * myNamespace.local.emit("foo", "bar");
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */

  }, {
    key: "local",
    get: function get() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
    }
  }]);

  return Namespace;
}(typed_events_1.StrictEventEmitter);

exports.Namespace = Namespace;
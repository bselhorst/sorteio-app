"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoteSocket = exports.BroadcastOperator = void 0;

var socket_types_1 = require("./socket-types");

var socket_io_parser_1 = require("socket.io-parser");

var BroadcastOperator =
/*#__PURE__*/
function () {
  function BroadcastOperator(adapter) {
    var rooms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
    var exceptRooms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
    var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, BroadcastOperator);

    this.adapter = adapter;
    this.rooms = rooms;
    this.exceptRooms = exceptRooms;
    this.flags = flags;
  }
  /**
   * Targets a room when emitting.
   *
   * @example
   * // the “foo” event will be broadcast to all connected clients in the “room-101” room
   * io.to("room-101").emit("foo", "bar");
   *
   * // with an array of rooms (a client will be notified at most once)
   * io.to(["room-101", "room-102"]).emit("foo", "bar");
   *
   * // with multiple chained calls
   * io.to("room-101").to("room-102").emit("foo", "bar");
   *
   * @param room - a room, or an array of rooms
   * @return a new {@link BroadcastOperator} instance for chaining
   */


  _createClass(BroadcastOperator, [{
    key: "to",
    value: function to(room) {
      var rooms = new Set(this.rooms);

      if (Array.isArray(room)) {
        room.forEach(function (r) {
          return rooms.add(r);
        });
      } else {
        rooms.add(room);
      }

      return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
    }
    /**
     * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
     *
     * @example
     * // disconnect all clients in the "room-101" room
     * io.in("room-101").disconnectSockets();
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */

  }, {
    key: "in",
    value: function _in(room) {
      return this.to(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @example
     * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
     * io.except("room-101").emit("foo", "bar");
     *
     * // with an array of rooms
     * io.except(["room-101", "room-102"]).emit("foo", "bar");
     *
     * // with multiple chained calls
     * io.except("room-101").except("room-102").emit("foo", "bar");
     *
     * @param room - a room, or an array of rooms
     * @return a new {@link BroadcastOperator} instance for chaining
     */

  }, {
    key: "except",
    value: function except(room) {
      var exceptRooms = new Set(this.exceptRooms);

      if (Array.isArray(room)) {
        room.forEach(function (r) {
          return exceptRooms.add(r);
        });
      } else {
        exceptRooms.add(room);
      }

      return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * io.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new BroadcastOperator instance
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      var flags = Object.assign({}, this.flags, {
        compress: _compress
      });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @example
     * io.volatile.emit("hello"); // the clients may or may not receive it
     *
     * @return a new BroadcastOperator instance
     */

  }, {
    key: "timeout",

    /**
     * Adds a timeout in milliseconds for the next operation
     *
     * @example
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @param timeout
     */
    value: function timeout(_timeout) {
      var flags = Object.assign({}, this.flags, {
        timeout: _timeout
      });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Emits to all clients.
     *
     * @example
     * // the “foo” event will be broadcast to all connected clients
     * io.emit("foo", "bar");
     *
     * // the “foo” event will be broadcast to all connected clients in the “room-101” room
     * io.to("room-101").emit("foo", "bar");
     *
     * // with an acknowledgement expected from all connected clients
     * io.timeout(1000).emit("some-event", (err, responses) => {
     *   if (err) {
     *     // some clients did not acknowledge the event in the given delay
     *   } else {
     *     console.log(responses); // one response per client
     *   }
     * });
     *
     * @return Always true
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      var _this = this;

      if (socket_types_1.RESERVED_EVENTS.has(ev)) {
        throw new Error("\"".concat(String(ev), "\" is a reserved event name"));
      } // set up packet object


      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var data = [ev].concat(args);
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: data
      };
      var withAck = typeof data[data.length - 1] === "function";

      if (!withAck) {
        this.adapter.broadcast(packet, {
          rooms: this.rooms,
          except: this.exceptRooms,
          flags: this.flags
        });
        return true;
      }

      var ack = data.pop();
      var timedOut = false;
      var responses = [];
      var timer = setTimeout(function () {
        timedOut = true;
        ack.apply(_this, [new Error("operation has timed out"), _this.flags.expectSingleResponse ? null : responses]);
      }, this.flags.timeout);
      var expectedServerCount = -1;
      var actualServerCount = 0;
      var expectedClientCount = 0;

      var checkCompleteness = function checkCompleteness() {
        if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {
          clearTimeout(timer);
          ack.apply(_this, [null, _this.flags.expectSingleResponse ? responses[0] : responses]);
        }
      };

      this.adapter.broadcastWithAck(packet, {
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, function (clientCount) {
        // each Socket.IO server in the cluster sends the number of clients that were notified
        expectedClientCount += clientCount;
        actualServerCount++;
        checkCompleteness();
      }, function (clientResponse) {
        // each client sends an acknowledgement
        responses.push(clientResponse);
        checkCompleteness();
      });
      this.adapter.serverCount().then(function (serverCount) {
        expectedServerCount = serverCount;
        checkCompleteness();
      });
      return true;
    }
    /**
     * Emits an event and waits for an acknowledgement from all clients.
     *
     * @example
     * try {
     *   const responses = await io.timeout(1000).emitWithAck("some-event");
     *   console.log(responses); // one response per client
     * } catch (e) {
     *   // some clients did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when all clients have acknowledged the event
     */

  }, {
    key: "emitWithAck",
    value: function emitWithAck(ev) {
      var _this2 = this;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return new Promise(function (resolve, reject) {
        args.push(function (err, responses) {
          if (err) {
            err.responses = responses;
            return reject(err);
          } else {
            return resolve(responses);
          }
        });

        _this2.emit.apply(_this2, [ev].concat(args));
      });
    }
    /**
     * Gets a list of clients.
     *
     * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
     * {@link fetchSockets} instead.
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      if (!this.adapter) {
        throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
      }

      return this.adapter.sockets(this.rooms);
    }
    /**
     * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // return all Socket instances
     * const sockets = await io.fetchSockets();
     *
     * // return all Socket instances in the "room1" room
     * const sockets = await io.in("room1").fetchSockets();
     *
     * for (const socket of sockets) {
     *   console.log(socket.id);
     *   console.log(socket.handshake);
     *   console.log(socket.rooms);
     *   console.log(socket.data);
     *
     *   socket.emit("hello");
     *   socket.join("room1");
     *   socket.leave("room2");
     *   socket.disconnect();
     * }
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      var _this3 = this;

      return this.adapter.fetchSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }).then(function (sockets) {
        return sockets.map(function (socket) {
          if (socket.server) {
            return socket; // local instance
          } else {
            return new RemoteSocket(_this3.adapter, socket);
          }
        });
      });
    }
    /**
     * Makes the matching socket instances join the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     *
     * // make all socket instances join the "room1" room
     * io.socketsJoin("room1");
     *
     * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
     * io.in("room1").socketsJoin(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      this.adapter.addSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances leave the specified rooms.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances leave the "room1" room
     * io.socketsLeave("room1");
     *
     * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
     * io.in("room1").socketsLeave(["room2", "room3"]);
     *
     * @param room - a room, or an array of rooms
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      this.adapter.delSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances disconnect.
     *
     * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
     *
     * @example
     * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
     * io.disconnectSockets();
     *
     * // make all socket instances in the "room1" room disconnect and close the underlying connections
     * io.in("room1").disconnectSockets(true);
     *
     * @param close - whether to close the underlying connection
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.adapter.disconnectSockets({
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      }, close);
    }
  }, {
    key: "volatile",
    get: function get() {
      var flags = Object.assign({}, this.flags, {
        "volatile": true
      });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @example
     * // the “foo” event will be broadcast to all connected clients on this node
     * io.local.emit("foo", "bar");
     *
     * @return a new {@link BroadcastOperator} instance for chaining
     */

  }, {
    key: "local",
    get: function get() {
      var flags = Object.assign({}, this.flags, {
        local: true
      });
      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
  }]);

  return BroadcastOperator;
}();

exports.BroadcastOperator = BroadcastOperator;
/**
 * Expose of subset of the attributes and methods of the Socket class
 */

var RemoteSocket =
/*#__PURE__*/
function () {
  function RemoteSocket(adapter, details) {
    _classCallCheck(this, RemoteSocket);

    this.id = details.id;
    this.handshake = details.handshake;
    this.rooms = new Set(details.rooms);
    this.data = details.data;
    this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set(), {
      expectSingleResponse: true // so that remoteSocket.emit() with acknowledgement behaves like socket.emit()

    });
  }
  /**
   * Adds a timeout in milliseconds for the next operation.
   *
   * @example
   * const sockets = await io.fetchSockets();
   *
   * for (const socket of sockets) {
   *   if (someCondition) {
   *     socket.timeout(1000).emit("some-event", (err) => {
   *       if (err) {
   *         // the client did not acknowledge the event in the given delay
   *       }
   *     });
   *   }
   * }
   *
   * // note: if possible, using a room instead of looping over all sockets is preferable
   * io.timeout(1000).to(someConditionRoom).emit("some-event", (err, responses) => {
   *   // ...
   * });
   *
   * @param timeout
   */


  _createClass(RemoteSocket, [{
    key: "timeout",
    value: function timeout(_timeout2) {
      return this.operator.timeout(_timeout2);
    }
  }, {
    key: "emit",
    value: function emit(ev) {
      var _this$operator;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return (_this$operator = this.operator).emit.apply(_this$operator, [ev].concat(args));
    }
    /**
     * Joins a room.
     *
     * @param {String|Array} room - room or array of rooms
     */

  }, {
    key: "join",
    value: function join(room) {
      return this.operator.socketsJoin(room);
    }
    /**
     * Leaves a room.
     *
     * @param {String} room
     */

  }, {
    key: "leave",
    value: function leave(room) {
      return this.operator.socketsLeave(room);
    }
    /**
     * Disconnects this client.
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return {Socket} self
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.operator.disconnectSockets(close);
      return this;
    }
  }]);

  return RemoteSocket;
}();

exports.RemoteSocket = RemoteSocket;
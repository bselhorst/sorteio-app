"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.MessageType = void 0;

var in_memory_adapter_1 = require("./in-memory-adapter");

var debug_1 = require("debug");

var crypto_1 = require("crypto");

var debug = (0, debug_1.debug)("socket.io-adapter");
var EMITTER_UID = "emitter";
var DEFAULT_TIMEOUT = 5000;

function randomId() {
  return (0, crypto_1.randomBytes)(8).toString("hex");
}

var MessageType;

(function (MessageType) {
  MessageType[MessageType["INITIAL_HEARTBEAT"] = 1] = "INITIAL_HEARTBEAT";
  MessageType[MessageType["HEARTBEAT"] = 2] = "HEARTBEAT";
  MessageType[MessageType["BROADCAST"] = 3] = "BROADCAST";
  MessageType[MessageType["SOCKETS_JOIN"] = 4] = "SOCKETS_JOIN";
  MessageType[MessageType["SOCKETS_LEAVE"] = 5] = "SOCKETS_LEAVE";
  MessageType[MessageType["DISCONNECT_SOCKETS"] = 6] = "DISCONNECT_SOCKETS";
  MessageType[MessageType["FETCH_SOCKETS"] = 7] = "FETCH_SOCKETS";
  MessageType[MessageType["FETCH_SOCKETS_RESPONSE"] = 8] = "FETCH_SOCKETS_RESPONSE";
  MessageType[MessageType["SERVER_SIDE_EMIT"] = 9] = "SERVER_SIDE_EMIT";
  MessageType[MessageType["SERVER_SIDE_EMIT_RESPONSE"] = 10] = "SERVER_SIDE_EMIT_RESPONSE";
  MessageType[MessageType["BROADCAST_CLIENT_COUNT"] = 11] = "BROADCAST_CLIENT_COUNT";
  MessageType[MessageType["BROADCAST_ACK"] = 12] = "BROADCAST_ACK";
  MessageType[MessageType["ADAPTER_CLOSE"] = 13] = "ADAPTER_CLOSE";
})(MessageType = exports.MessageType || (exports.MessageType = {}));

function encodeOptions(opts) {
  return {
    rooms: _toConsumableArray(opts.rooms),
    except: _toConsumableArray(opts.except),
    flags: opts.flags
  };
}

function decodeOptions(opts) {
  return {
    rooms: new Set(opts.rooms),
    except: new Set(opts.except),
    flags: opts.flags
  };
}
/**
 * A cluster-ready adapter. Any extending class must:
 *
 * - implement {@link ClusterAdapter#doPublish} and {@link ClusterAdapter#doPublishResponse}
 * - call {@link ClusterAdapter#onMessage} and {@link ClusterAdapter#onResponse}
 */


var ClusterAdapter =
/*#__PURE__*/
function (_in_memory_adapter_1$) {
  _inherits(ClusterAdapter, _in_memory_adapter_1$);

  function ClusterAdapter(nsp) {
    var _this;

    _classCallCheck(this, ClusterAdapter);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClusterAdapter).call(this, nsp));
    _this.requests = new Map();
    _this.ackRequests = new Map();
    _this.uid = randomId();
    return _this;
  }
  /**
   * Called when receiving a message from another member of the cluster.
   *
   * @param message
   * @param offset
   * @protected
   */


  _createClass(ClusterAdapter, [{
    key: "onMessage",
    value: function onMessage(message, offset) {
      var _this2 = this;

      if (message.uid === this.uid) {
        return debug("[%s] ignore message from self", this.uid);
      }

      debug("[%s] new event of type %d from %s", this.uid, message.type, message.uid);

      switch (message.type) {
        case MessageType.BROADCAST:
          {
            var withAck = message.data.requestId !== undefined;

            if (withAck) {
              _get(_getPrototypeOf(ClusterAdapter.prototype), "broadcastWithAck", this).call(this, message.data.packet, decodeOptions(message.data.opts), function (clientCount) {
                debug("[%s] waiting for %d client acknowledgements", _this2.uid, clientCount);

                _this2.publishResponse(message.uid, {
                  type: MessageType.BROADCAST_CLIENT_COUNT,
                  data: {
                    requestId: message.data.requestId,
                    clientCount: clientCount
                  }
                });
              }, function (arg) {
                debug("[%s] received acknowledgement with value %j", _this2.uid, arg);

                _this2.publishResponse(message.uid, {
                  type: MessageType.BROADCAST_ACK,
                  data: {
                    requestId: message.data.requestId,
                    packet: arg
                  }
                });
              });
            } else {
              var packet = message.data.packet;
              var opts = decodeOptions(message.data.opts);
              this.addOffsetIfNecessary(packet, opts, offset);

              _get(_getPrototypeOf(ClusterAdapter.prototype), "broadcast", this).call(this, packet, opts);
            }

            break;
          }

        case MessageType.SOCKETS_JOIN:
          _get(_getPrototypeOf(ClusterAdapter.prototype), "addSockets", this).call(this, decodeOptions(message.data.opts), message.data.rooms);

          break;

        case MessageType.SOCKETS_LEAVE:
          _get(_getPrototypeOf(ClusterAdapter.prototype), "delSockets", this).call(this, decodeOptions(message.data.opts), message.data.rooms);

          break;

        case MessageType.DISCONNECT_SOCKETS:
          _get(_getPrototypeOf(ClusterAdapter.prototype), "disconnectSockets", this).call(this, decodeOptions(message.data.opts), message.data.close);

          break;

        case MessageType.FETCH_SOCKETS:
          {
            debug("[%s] calling fetchSockets with opts %j", this.uid, message.data.opts);

            _get(_getPrototypeOf(ClusterAdapter.prototype), "fetchSockets", this).call(this, decodeOptions(message.data.opts)).then(function (localSockets) {
              _this2.publishResponse(message.uid, {
                type: MessageType.FETCH_SOCKETS_RESPONSE,
                data: {
                  requestId: message.data.requestId,
                  sockets: localSockets.map(function (socket) {
                    // remove sessionStore from handshake, as it may contain circular references
                    var _a = socket.handshake,
                        sessionStore = _a.sessionStore,
                        handshake = __rest(_a, ["sessionStore"]);

                    return {
                      id: socket.id,
                      handshake: handshake,
                      rooms: _toConsumableArray(socket.rooms),
                      data: socket.data
                    };
                  })
                }
              });
            });

            break;
          }

        case MessageType.SERVER_SIDE_EMIT:
          {
            var _packet = message.data.packet;

            var _withAck = message.data.requestId !== undefined;

            if (!_withAck) {
              this.nsp._onServerSideEmit(_packet);

              return;
            }

            var called = false;

            var callback = function callback(arg) {
              // only one argument is expected
              if (called) {
                return;
              }

              called = true;
              debug("[%s] calling acknowledgement with %j", _this2.uid, arg);

              _this2.publishResponse(message.uid, {
                type: MessageType.SERVER_SIDE_EMIT_RESPONSE,
                data: {
                  requestId: message.data.requestId,
                  packet: arg
                }
              });
            };

            this.nsp._onServerSideEmit([].concat(_toConsumableArray(_packet), [callback]));

            break;
          }
        // @ts-ignore

        case MessageType.BROADCAST_CLIENT_COUNT: // @ts-ignore

        case MessageType.BROADCAST_ACK: // @ts-ignore

        case MessageType.FETCH_SOCKETS_RESPONSE: // @ts-ignore

        case MessageType.SERVER_SIDE_EMIT_RESPONSE:
          // extending classes may not make a distinction between a ClusterMessage and a ClusterResponse payload and may
          // always call the onMessage() method
          this.onResponse(message);
          break;

        default:
          debug("[%s] unknown message type: %s", this.uid, message.type);
      }
    }
    /**
     * Called when receiving a response from another member of the cluster.
     *
     * @param response
     * @protected
     */

  }, {
    key: "onResponse",
    value: function onResponse(response) {
      var _a, _b;

      var requestId = response.data.requestId;
      debug("[%s] received response %s to request %s", this.uid, response.type, requestId);

      switch (response.type) {
        case MessageType.BROADCAST_CLIENT_COUNT:
          {
            (_a = this.ackRequests.get(requestId)) === null || _a === void 0 ? void 0 : _a.clientCountCallback(response.data.clientCount);
            break;
          }

        case MessageType.BROADCAST_ACK:
          {
            (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response.data.packet);
            break;
          }

        case MessageType.FETCH_SOCKETS_RESPONSE:
          {
            var request = this.requests.get(requestId);

            if (!request) {
              return;
            }

            request.current++;
            response.data.sockets.forEach(function (socket) {
              return request.responses.push(socket);
            });

            if (request.current === request.expected) {
              clearTimeout(request.timeout);
              request.resolve(request.responses);
              this.requests["delete"](requestId);
            }

            break;
          }

        case MessageType.SERVER_SIDE_EMIT_RESPONSE:
          {
            var _request = this.requests.get(requestId);

            if (!_request) {
              return;
            }

            _request.current++;

            _request.responses.push(response.data.packet);

            if (_request.current === _request.expected) {
              clearTimeout(_request.timeout);

              _request.resolve(null, _request.responses);

              this.requests["delete"](requestId);
            }

            break;
          }

        default:
          // @ts-ignore
          debug("[%s] unknown response type: %s", this.uid, response.type);
      }
    }
  }, {
    key: "broadcast",
    value: function broadcast(packet, opts) {
      var _a, onlyLocal, offset;

      return regeneratorRuntime.async(function broadcast$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;

              if (onlyLocal) {
                _context.next = 12;
                break;
              }

              _context.prev = 2;
              _context.next = 5;
              return regeneratorRuntime.awrap(this.publishAndReturnOffset({
                type: MessageType.BROADCAST,
                data: {
                  packet: packet,
                  opts: encodeOptions(opts)
                }
              }));

            case 5:
              offset = _context.sent;
              this.addOffsetIfNecessary(packet, opts, offset);
              _context.next = 12;
              break;

            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](2);
              return _context.abrupt("return", debug("[%s] error while broadcasting message: %s", this.uid, _context.t0.message));

            case 12:
              _get(_getPrototypeOf(ClusterAdapter.prototype), "broadcast", this).call(this, packet, opts);

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[2, 9]]);
    }
    /**
     * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it
     * reconnects after a temporary disconnection.
     *
     * @param packet
     * @param opts
     * @param offset
     * @private
     */

  }, {
    key: "addOffsetIfNecessary",
    value: function addOffsetIfNecessary(packet, opts, offset) {
      var _a;

      if (!this.nsp.server.opts.connectionStateRecovery) {
        return;
      }

      var isEventPacket = packet.type === 2; // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and
      // restored on another server upon reconnection

      var withoutAcknowledgement = packet.id === undefined;
      var notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a["volatile"]) === undefined;

      if (isEventPacket && withoutAcknowledgement && notVolatile) {
        packet.data.push(offset);
      }
    }
  }, {
    key: "broadcastWithAck",
    value: function broadcastWithAck(packet, opts, clientCountCallback, ack) {
      var _this3 = this;

      var _a;

      var onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;

      if (!onlyLocal) {
        var requestId = randomId();
        this.ackRequests.set(requestId, {
          clientCountCallback: clientCountCallback,
          ack: ack
        });
        this.publish({
          type: MessageType.BROADCAST,
          data: {
            packet: packet,
            requestId: requestId,
            opts: encodeOptions(opts)
          }
        }); // we have no way to know at this level whether the server has received an acknowledgement from each client, so we
        // will simply clean up the ackRequests map after the given delay

        setTimeout(function () {
          _this3.ackRequests["delete"](requestId);
        }, opts.flags.timeout);
      }

      _get(_getPrototypeOf(ClusterAdapter.prototype), "broadcastWithAck", this).call(this, packet, opts, clientCountCallback, ack);
    }
  }, {
    key: "addSockets",
    value: function addSockets(opts, rooms) {
      var _a, onlyLocal;

      return regeneratorRuntime.async(function addSockets$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;

              if (onlyLocal) {
                _context2.next = 10;
                break;
              }

              _context2.prev = 2;
              _context2.next = 5;
              return regeneratorRuntime.awrap(this.publishAndReturnOffset({
                type: MessageType.SOCKETS_JOIN,
                data: {
                  opts: encodeOptions(opts),
                  rooms: rooms
                }
              }));

            case 5:
              _context2.next = 10;
              break;

            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2["catch"](2);
              debug("[%s] error while publishing message: %s", this.uid, _context2.t0.message);

            case 10:
              _get(_getPrototypeOf(ClusterAdapter.prototype), "addSockets", this).call(this, opts, rooms);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[2, 7]]);
    }
  }, {
    key: "delSockets",
    value: function delSockets(opts, rooms) {
      var _a, onlyLocal;

      return regeneratorRuntime.async(function delSockets$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;

              if (onlyLocal) {
                _context3.next = 10;
                break;
              }

              _context3.prev = 2;
              _context3.next = 5;
              return regeneratorRuntime.awrap(this.publishAndReturnOffset({
                type: MessageType.SOCKETS_LEAVE,
                data: {
                  opts: encodeOptions(opts),
                  rooms: rooms
                }
              }));

            case 5:
              _context3.next = 10;
              break;

            case 7:
              _context3.prev = 7;
              _context3.t0 = _context3["catch"](2);
              debug("[%s] error while publishing message: %s", this.uid, _context3.t0.message);

            case 10:
              _get(_getPrototypeOf(ClusterAdapter.prototype), "delSockets", this).call(this, opts, rooms);

            case 11:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[2, 7]]);
    }
  }, {
    key: "disconnectSockets",
    value: function disconnectSockets(opts, close) {
      var _a, onlyLocal;

      return regeneratorRuntime.async(function disconnectSockets$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;

              if (onlyLocal) {
                _context4.next = 10;
                break;
              }

              _context4.prev = 2;
              _context4.next = 5;
              return regeneratorRuntime.awrap(this.publishAndReturnOffset({
                type: MessageType.DISCONNECT_SOCKETS,
                data: {
                  opts: encodeOptions(opts),
                  close: close
                }
              }));

            case 5:
              _context4.next = 10;
              break;

            case 7:
              _context4.prev = 7;
              _context4.t0 = _context4["catch"](2);
              debug("[%s] error while publishing message: %s", this.uid, _context4.t0.message);

            case 10:
              _get(_getPrototypeOf(ClusterAdapter.prototype), "disconnectSockets", this).call(this, opts, close);

            case 11:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this, [[2, 7]]);
    }
  }, {
    key: "fetchSockets",
    value: function fetchSockets(opts) {
      var _this4 = this;

      var _a, _ref, _ref2, localSockets, serverCount, expectedResponseCount, requestId;

      return regeneratorRuntime.async(function fetchSockets$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return regeneratorRuntime.awrap(Promise.all([_get(_getPrototypeOf(ClusterAdapter.prototype), "fetchSockets", this).call(this, opts), this.serverCount()]));

            case 2:
              _ref = _context5.sent;
              _ref2 = _slicedToArray(_ref, 2);
              localSockets = _ref2[0];
              serverCount = _ref2[1];
              expectedResponseCount = serverCount - 1;

              if (!(((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0)) {
                _context5.next = 9;
                break;
              }

              return _context5.abrupt("return", localSockets);

            case 9:
              requestId = randomId();
              return _context5.abrupt("return", new Promise(function (resolve, reject) {
                var timeout = setTimeout(function () {
                  var storedRequest = _this4.requests.get(requestId);

                  if (storedRequest) {
                    reject(new Error("timeout reached: only ".concat(storedRequest.current, " responses received out of ").concat(storedRequest.expected)));

                    _this4.requests["delete"](requestId);
                  }
                }, opts.flags.timeout || DEFAULT_TIMEOUT);
                var storedRequest = {
                  type: MessageType.FETCH_SOCKETS,
                  resolve: resolve,
                  timeout: timeout,
                  current: 0,
                  expected: expectedResponseCount,
                  responses: localSockets
                };

                _this4.requests.set(requestId, storedRequest);

                _this4.publish({
                  type: MessageType.FETCH_SOCKETS,
                  data: {
                    opts: encodeOptions(opts),
                    requestId: requestId
                  }
                });
              }));

            case 11:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(packet) {
      var _this5 = this;

      var withAck, ack, expectedResponseCount, requestId, timeout, storedRequest;
      return regeneratorRuntime.async(function serverSideEmit$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              withAck = typeof packet[packet.length - 1] === "function";

              if (withAck) {
                _context6.next = 3;
                break;
              }

              return _context6.abrupt("return", this.publish({
                type: MessageType.SERVER_SIDE_EMIT,
                data: {
                  packet: packet
                }
              }));

            case 3:
              ack = packet.pop();
              _context6.next = 6;
              return regeneratorRuntime.awrap(this.serverCount());

            case 6:
              _context6.t0 = _context6.sent;
              expectedResponseCount = _context6.t0 - 1;
              debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);

              if (!(expectedResponseCount <= 0)) {
                _context6.next = 11;
                break;
              }

              return _context6.abrupt("return", ack(null, []));

            case 11:
              requestId = randomId();
              timeout = setTimeout(function () {
                var storedRequest = _this5.requests.get(requestId);

                if (storedRequest) {
                  ack(new Error("timeout reached: only ".concat(storedRequest.current, " responses received out of ").concat(storedRequest.expected)), storedRequest.responses);

                  _this5.requests["delete"](requestId);
                }
              }, DEFAULT_TIMEOUT);
              storedRequest = {
                type: MessageType.SERVER_SIDE_EMIT,
                resolve: ack,
                timeout: timeout,
                current: 0,
                expected: expectedResponseCount,
                responses: []
              };
              this.requests.set(requestId, storedRequest);
              this.publish({
                type: MessageType.SERVER_SIDE_EMIT,
                data: {
                  requestId: requestId,
                  packet: packet
                }
              });

            case 16:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "publish",
    value: function publish(message) {
      var _this6 = this;

      this.publishAndReturnOffset(message)["catch"](function (err) {
        debug("[%s] error while publishing message: %s", _this6.uid, err);
      });
    }
  }, {
    key: "publishAndReturnOffset",
    value: function publishAndReturnOffset(message) {
      message.uid = this.uid;
      message.nsp = this.nsp.name;
      return this.doPublish(message);
    }
  }, {
    key: "publishResponse",
    value: function publishResponse(requesterUid, response) {
      var _this7 = this;

      response.uid = this.uid;
      response.nsp = this.nsp.name;
      this.doPublishResponse(requesterUid, response)["catch"](function (err) {
        debug("[%s] error while publishing response: %s", _this7.uid, err);
      });
    }
  }]);

  return ClusterAdapter;
}(in_memory_adapter_1.Adapter);

exports.ClusterAdapter = ClusterAdapter;

var ClusterAdapterWithHeartbeat =
/*#__PURE__*/
function (_ClusterAdapter) {
  _inherits(ClusterAdapterWithHeartbeat, _ClusterAdapter);

  function ClusterAdapterWithHeartbeat(nsp, opts) {
    var _this8;

    _classCallCheck(this, ClusterAdapterWithHeartbeat);

    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(ClusterAdapterWithHeartbeat).call(this, nsp));
    _this8.nodesMap = new Map(); // uid => timestamp of last message

    _this8.customRequests = new Map();
    _this8._opts = Object.assign({
      heartbeatInterval: 5000,
      heartbeatTimeout: 10000
    }, opts);
    _this8.cleanupTimer = setInterval(function () {
      var now = Date.now();

      _this8.nodesMap.forEach(function (lastSeen, uid) {
        var nodeSeemsDown = now - lastSeen > _this8._opts.heartbeatTimeout;

        if (nodeSeemsDown) {
          debug("[%s] node %s seems down", _this8.uid, uid);

          _this8.removeNode(uid);
        }
      });
    }, 1000);
    return _this8;
  }

  _createClass(ClusterAdapterWithHeartbeat, [{
    key: "init",
    value: function init() {
      this.publish({
        type: MessageType.INITIAL_HEARTBEAT
      });
    }
  }, {
    key: "scheduleHeartbeat",
    value: function scheduleHeartbeat() {
      var _this9 = this;

      if (this.heartbeatTimer) {
        this.heartbeatTimer.refresh();
      } else {
        this.heartbeatTimer = setTimeout(function () {
          _this9.publish({
            type: MessageType.HEARTBEAT
          });
        }, this._opts.heartbeatInterval);
      }
    }
  }, {
    key: "close",
    value: function close() {
      this.publish({
        type: MessageType.ADAPTER_CLOSE
      });
      clearTimeout(this.heartbeatTimer);

      if (this.cleanupTimer) {
        clearInterval(this.cleanupTimer);
      }
    }
  }, {
    key: "onMessage",
    value: function onMessage(message, offset) {
      if (message.uid === this.uid) {
        return debug("[%s] ignore message from self", this.uid);
      }

      if (message.uid && message.uid !== EMITTER_UID) {
        // we track the UID of each sender, in order to know how many servers there are in the cluster
        this.nodesMap.set(message.uid, Date.now());
      }

      debug("[%s] new event of type %d from %s", this.uid, message.type, message.uid);

      switch (message.type) {
        case MessageType.INITIAL_HEARTBEAT:
          this.publish({
            type: MessageType.HEARTBEAT
          });
          break;

        case MessageType.HEARTBEAT:
          // nothing to do
          break;

        case MessageType.ADAPTER_CLOSE:
          this.removeNode(message.uid);
          break;

        default:
          _get(_getPrototypeOf(ClusterAdapterWithHeartbeat.prototype), "onMessage", this).call(this, message, offset);

      }
    }
  }, {
    key: "serverCount",
    value: function serverCount() {
      return Promise.resolve(1 + this.nodesMap.size);
    }
  }, {
    key: "publish",
    value: function publish(message) {
      this.scheduleHeartbeat();
      return _get(_getPrototypeOf(ClusterAdapterWithHeartbeat.prototype), "publish", this).call(this, message);
    }
  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(packet) {
      var _this10 = this;

      var withAck, ack, expectedResponseCount, requestId, timeout, storedRequest;
      return regeneratorRuntime.async(function serverSideEmit$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              withAck = typeof packet[packet.length - 1] === "function";

              if (withAck) {
                _context7.next = 3;
                break;
              }

              return _context7.abrupt("return", this.publish({
                type: MessageType.SERVER_SIDE_EMIT,
                data: {
                  packet: packet
                }
              }));

            case 3:
              ack = packet.pop();
              expectedResponseCount = this.nodesMap.size;
              debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);

              if (!(expectedResponseCount <= 0)) {
                _context7.next = 8;
                break;
              }

              return _context7.abrupt("return", ack(null, []));

            case 8:
              requestId = randomId();
              timeout = setTimeout(function () {
                var storedRequest = _this10.customRequests.get(requestId);

                if (storedRequest) {
                  ack(new Error("timeout reached: missing ".concat(storedRequest.missingUids.size, " responses")), storedRequest.responses);

                  _this10.customRequests["delete"](requestId);
                }
              }, DEFAULT_TIMEOUT);
              storedRequest = {
                type: MessageType.SERVER_SIDE_EMIT,
                resolve: ack,
                timeout: timeout,
                missingUids: new Set(_toConsumableArray(this.nodesMap.keys())),
                responses: []
              };
              this.customRequests.set(requestId, storedRequest);
              this.publish({
                type: MessageType.SERVER_SIDE_EMIT,
                data: {
                  requestId: requestId,
                  packet: packet
                }
              });

            case 13:
            case "end":
              return _context7.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "fetchSockets",
    value: function fetchSockets(opts) {
      var _this11 = this;

      var _a, _ref3, _ref4, localSockets, serverCount, expectedResponseCount, requestId;

      return regeneratorRuntime.async(function fetchSockets$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return regeneratorRuntime.awrap(Promise.all([_get(_getPrototypeOf(ClusterAdapterWithHeartbeat.prototype), "fetchSockets", this).call(this, {
                rooms: opts.rooms,
                except: opts.except,
                flags: {
                  local: true
                }
              }), this.serverCount()]));

            case 2:
              _ref3 = _context8.sent;
              _ref4 = _slicedToArray(_ref3, 2);
              localSockets = _ref4[0];
              serverCount = _ref4[1];
              expectedResponseCount = serverCount - 1;

              if (!(((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0)) {
                _context8.next = 9;
                break;
              }

              return _context8.abrupt("return", localSockets);

            case 9:
              requestId = randomId();
              return _context8.abrupt("return", new Promise(function (resolve, reject) {
                var timeout = setTimeout(function () {
                  var storedRequest = _this11.customRequests.get(requestId);

                  if (storedRequest) {
                    reject(new Error("timeout reached: missing ".concat(storedRequest.missingUids.size, " responses")));

                    _this11.customRequests["delete"](requestId);
                  }
                }, opts.flags.timeout || DEFAULT_TIMEOUT);
                var storedRequest = {
                  type: MessageType.FETCH_SOCKETS,
                  resolve: resolve,
                  timeout: timeout,
                  missingUids: new Set(_toConsumableArray(_this11.nodesMap.keys())),
                  responses: localSockets
                };

                _this11.customRequests.set(requestId, storedRequest);

                _this11.publish({
                  type: MessageType.FETCH_SOCKETS,
                  data: {
                    opts: encodeOptions(opts),
                    requestId: requestId
                  }
                });
              }));

            case 11:
            case "end":
              return _context8.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "onResponse",
    value: function onResponse(response) {
      var requestId = response.data.requestId;
      debug("[%s] received response %s to request %s", this.uid, response.type, requestId);

      switch (response.type) {
        case MessageType.FETCH_SOCKETS_RESPONSE:
          {
            var request = this.customRequests.get(requestId);

            if (!request) {
              return;
            }

            response.data.sockets.forEach(function (socket) {
              return request.responses.push(socket);
            });
            request.missingUids["delete"](response.uid);

            if (request.missingUids.size === 0) {
              clearTimeout(request.timeout);
              request.resolve(request.responses);
              this.customRequests["delete"](requestId);
            }

            break;
          }

        case MessageType.SERVER_SIDE_EMIT_RESPONSE:
          {
            var _request2 = this.customRequests.get(requestId);

            if (!_request2) {
              return;
            }

            _request2.responses.push(response.data.packet);

            _request2.missingUids["delete"](response.uid);

            if (_request2.missingUids.size === 0) {
              clearTimeout(_request2.timeout);

              _request2.resolve(null, _request2.responses);

              this.customRequests["delete"](requestId);
            }

            break;
          }

        default:
          _get(_getPrototypeOf(ClusterAdapterWithHeartbeat.prototype), "onResponse", this).call(this, response);

      }
    }
  }, {
    key: "removeNode",
    value: function removeNode(uid) {
      var _this12 = this;

      this.customRequests.forEach(function (request, requestId) {
        request.missingUids["delete"](uid);

        if (request.missingUids.size === 0) {
          clearTimeout(request.timeout);

          if (request.type === MessageType.FETCH_SOCKETS) {
            request.resolve(request.responses);
          } else if (request.type === MessageType.SERVER_SIDE_EMIT) {
            request.resolve(null, request.responses);
          }

          _this12.customRequests["delete"](requestId);
        }
      });
      this.nodesMap["delete"](uid);
    }
  }]);

  return ClusterAdapterWithHeartbeat;
}(ClusterAdapter);

exports.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;
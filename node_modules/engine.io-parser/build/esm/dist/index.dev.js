"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPacketEncoderStream = createPacketEncoderStream;
exports.createPacketDecoderStream = createPacketDecoderStream;
Object.defineProperty(exports, "encodePacket", {
  enumerable: true,
  get: function get() {
    return _encodePacket.encodePacket;
  }
});
Object.defineProperty(exports, "decodePacket", {
  enumerable: true,
  get: function get() {
    return _decodePacket.decodePacket;
  }
});
exports.decodePayload = exports.encodePayload = exports.protocol = void 0;

var _encodePacket = require("./encodePacket.js");

var _decodePacket = require("./decodePacket.js");

var _commons = require("./commons.js");

var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

var encodePayload = function encodePayload(packets, callback) {
  // some packets may be added to the array while encoding, so the initial length must be saved
  var length = packets.length;
  var encodedPackets = new Array(length);
  var count = 0;
  packets.forEach(function (packet, i) {
    // force base64 encoding for binary packets
    (0, _encodePacket.encodePacket)(packet, false, function (encodedPacket) {
      encodedPackets[i] = encodedPacket;

      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};

exports.encodePayload = encodePayload;

var decodePayload = function decodePayload(encodedPayload, binaryType) {
  var encodedPackets = encodedPayload.split(SEPARATOR);
  var packets = [];

  for (var i = 0; i < encodedPackets.length; i++) {
    var decodedPacket = (0, _decodePacket.decodePacket)(encodedPackets[i], binaryType);
    packets.push(decodedPacket);

    if (decodedPacket.type === "error") {
      break;
    }
  }

  return packets;
};

exports.decodePayload = decodePayload;

function createPacketEncoderStream() {
  return new TransformStream({
    transform: function transform(packet, controller) {
      (0, _encodePacket.encodePacketToBinary)(packet, function (encodedPacket) {
        var payloadLength = encodedPacket.length;
        var header; // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length

        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          var view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);

          var _view = new DataView(header.buffer);

          _view.setUint8(0, 127);

          _view.setBigUint64(1, BigInt(payloadLength));
        } // first bit indicates whether the payload is plain text (0) or binary (1)


        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 0x80;
        }

        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}

var TEXT_DECODER;

function totalLength(chunks) {
  return chunks.reduce(function (acc, chunk) {
    return acc + chunk.length;
  }, 0);
}

function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }

  var buffer = new Uint8Array(size);
  var j = 0;

  for (var i = 0; i < size; i++) {
    buffer[i] = chunks[0][j++];

    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }

  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }

  return buffer;
}

function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }

  var chunks = [];
  var state = 0
  /* State.READ_HEADER */
  ;
  var expectedLength = -1;
  var isBinary = false;
  return new TransformStream({
    transform: function transform(chunk, controller) {
      chunks.push(chunk);

      while (true) {
        if (state === 0
        /* State.READ_HEADER */
        ) {
            if (totalLength(chunks) < 1) {
              break;
            }

            var header = concatChunks(chunks, 1);
            isBinary = (header[0] & 0x80) === 0x80;
            expectedLength = header[0] & 0x7f;

            if (expectedLength < 126) {
              state = 3
              /* State.READ_PAYLOAD */
              ;
            } else if (expectedLength === 126) {
              state = 1
              /* State.READ_EXTENDED_LENGTH_16 */
              ;
            } else {
              state = 2
              /* State.READ_EXTENDED_LENGTH_64 */
              ;
            }
          } else if (state === 1
        /* State.READ_EXTENDED_LENGTH_16 */
        ) {
            if (totalLength(chunks) < 2) {
              break;
            }

            var headerArray = concatChunks(chunks, 2);
            expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
            state = 3
            /* State.READ_PAYLOAD */
            ;
          } else if (state === 2
        /* State.READ_EXTENDED_LENGTH_64 */
        ) {
            if (totalLength(chunks) < 8) {
              break;
            }

            var _headerArray = concatChunks(chunks, 8);

            var view = new DataView(_headerArray.buffer, _headerArray.byteOffset, _headerArray.length);
            var n = view.getUint32(0);

            if (n > Math.pow(2, 53 - 32) - 1) {
              // the maximum safe integer in JavaScript is 2^53 - 1
              controller.enqueue(_commons.ERROR_PACKET);
              break;
            }

            expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
            state = 3
            /* State.READ_PAYLOAD */
            ;
          } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }

          var data = concatChunks(chunks, expectedLength);
          controller.enqueue((0, _decodePacket.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0
          /* State.READ_HEADER */
          ;
        }

        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(_commons.ERROR_PACKET);
          break;
        }
      }
    }
  });
}

var protocol = 4;
exports.protocol = protocol;
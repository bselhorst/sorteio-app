"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uServer = void 0;

var debug_1 = require("debug");

var server_1 = require("./server");

var transports_uws_1 = require("./transports-uws");

var debug = (0, debug_1["default"])("engine:uws");
/**
 * An Engine.IO server based on the `uWebSockets.js` package.
 */
// TODO export it into its own package

var uServer =
/*#__PURE__*/
function (_server_1$BaseServer) {
  _inherits(uServer, _server_1$BaseServer);

  function uServer() {
    _classCallCheck(this, uServer);

    return _possibleConstructorReturn(this, _getPrototypeOf(uServer).apply(this, arguments));
  }

  _createClass(uServer, [{
    key: "init",
    value: function init() {}
  }, {
    key: "cleanup",
    value: function cleanup() {}
    /**
     * Prepares a request by processing the query string.
     *
     * @private
     */

  }, {
    key: "prepare",
    value: function prepare(req, res) {
      req.method = req.getMethod().toUpperCase();
      req.url = req.getUrl();
      var params = new URLSearchParams(req.getQuery());
      req._query = Object.fromEntries(params.entries());
      req.headers = {};
      req.forEach(function (key, value) {
        req.headers[key] = value;
      });
      req.connection = {
        remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()
      };
      res.onAborted(function () {
        debug("response has been aborted");
      });
    }
  }, {
    key: "createTransport",
    value: function createTransport(transportName, req) {
      return new transports_uws_1["default"][transportName](req);
    }
    /**
     * Attach the engine to a ÂµWebSockets.js server
     * @param app
     * @param options
     */

  }, {
    key: "attach",
    value: function attach(app
    /* : TemplatedApp */
    ) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var path = this._computePath(options);

      app.any(path, this.handleRequest.bind(this)) //
      .ws(path, {
        compression: options.compression,
        idleTimeout: options.idleTimeout,
        maxBackpressure: options.maxBackpressure,
        maxPayloadLength: this.opts.maxHttpBufferSize,
        upgrade: this.handleUpgrade.bind(this),
        open: function open(ws) {
          var transport = ws.getUserData().transport;
          transport.socket = ws;
          transport.writable = true;
          transport.emit("ready");
        },
        message: function message(ws, _message, isBinary) {
          ws.getUserData().transport.onData(isBinary ? _message : Buffer.from(_message).toString());
        },
        close: function close(ws, code, message) {
          ws.getUserData().transport.onClose(code, message);
        }
      });
    }
  }, {
    key: "_applyMiddlewares",
    value: function _applyMiddlewares(req, res, callback) {
      if (this.middlewares.length === 0) {
        return callback();
      } // needed to buffer headers until the status is computed


      req.res = new ResponseWrapper(res);

      _get(_getPrototypeOf(uServer.prototype), "_applyMiddlewares", this).call(this, req, req.res, function (err) {
        // some middlewares (like express-session) wait for the writeHead() call to flush their headers
        // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244
        req.res.writeHead();
        callback(err);
      });
    }
  }, {
    key: "handleRequest",
    value: function handleRequest(res, req) {
      var _this = this;

      debug('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
      this.prepare(req, res);
      req.res = res;

      var callback = function callback(errorCode, errorContext) {
        if (errorCode !== undefined) {
          _this.emit("connection_error", {
            req: req,
            code: errorCode,
            message: server_1.Server.errorMessages[errorCode],
            context: errorContext
          });

          _this.abortRequest(req.res, errorCode, errorContext);

          return;
        }

        if (req._query.sid) {
          debug("setting new request for existing client"); // @ts-ignore

          _this.clients[req._query.sid].transport.onRequest(req);
        } else {
          var closeConnection = function closeConnection(errorCode, errorContext) {
            return _this.abortRequest(res, errorCode, errorContext);
          };

          _this.handshake(req._query.transport, req, closeConnection);
        }
      };

      this._applyMiddlewares(req, res, function (err) {
        if (err) {
          callback(server_1.Server.errors.BAD_REQUEST, {
            name: "MIDDLEWARE_FAILURE"
          });
        } else {
          _this.verify(req, false, callback);
        }
      });
    }
  }, {
    key: "handleUpgrade",
    value: function handleUpgrade(res, req, context) {
      var _this2 = this;

      debug("on upgrade");
      this.prepare(req, res);
      req.res = res;

      var callback = function callback(errorCode, errorContext) {
        var id, transport, client;
        return regeneratorRuntime.async(function callback$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(errorCode !== undefined)) {
                  _context.next = 4;
                  break;
                }

                _this2.emit("connection_error", {
                  req: req,
                  code: errorCode,
                  message: server_1.Server.errorMessages[errorCode],
                  context: errorContext
                });

                _this2.abortRequest(res, errorCode, errorContext);

                return _context.abrupt("return");

              case 4:
                id = req._query.sid;

                if (!id) {
                  _context.next = 27;
                  break;
                }

                client = _this2.clients[id];

                if (client) {
                  _context.next = 12;
                  break;
                }

                debug("upgrade attempt for closed client");
                return _context.abrupt("return", res.close());

              case 12:
                if (!client.upgrading) {
                  _context.next = 17;
                  break;
                }

                debug("transport has already been trying to upgrade");
                return _context.abrupt("return", res.close());

              case 17:
                if (!client.upgraded) {
                  _context.next = 22;
                  break;
                }

                debug("transport had already been upgraded");
                return _context.abrupt("return", res.close());

              case 22:
                debug("upgrading existing transport");
                transport = _this2.createTransport(req._query.transport, req);

                client._maybeUpgrade(transport);

              case 25:
                _context.next = 32;
                break;

              case 27:
                _context.next = 29;
                return regeneratorRuntime.awrap(_this2.handshake(req._query.transport, req, function (errorCode, errorContext) {
                  return _this2.abortRequest(res, errorCode, errorContext);
                }));

              case 29:
                transport = _context.sent;

                if (transport) {
                  _context.next = 32;
                  break;
                }

                return _context.abrupt("return");

              case 32:
                // calling writeStatus() triggers the flushing of any header added in a middleware
                req.res.writeStatus("101 Switching Protocols");
                res.upgrade({
                  transport: transport
                }, req.getHeader("sec-websocket-key"), req.getHeader("sec-websocket-protocol"), req.getHeader("sec-websocket-extensions"), context);

              case 34:
              case "end":
                return _context.stop();
            }
          }
        });
      };

      this._applyMiddlewares(req, res, function (err) {
        if (err) {
          callback(server_1.Server.errors.BAD_REQUEST, {
            name: "MIDDLEWARE_FAILURE"
          });
        } else {
          _this2.verify(req, true, callback);
        }
      });
    }
  }, {
    key: "abortRequest",
    value: function abortRequest(res, errorCode, errorContext) {
      var statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? "403 Forbidden" : "400 Bad Request";
      var message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];
      res.writeStatus(statusCode);
      res.writeHeader("Content-Type", "application/json");
      res.end(JSON.stringify({
        code: errorCode,
        message: message
      }));
    }
  }]);

  return uServer;
}(server_1.BaseServer);

exports.uServer = uServer;

var ResponseWrapper =
/*#__PURE__*/
function () {
  function ResponseWrapper(res) {
    _classCallCheck(this, ResponseWrapper);

    this.res = res;
    this.statusWritten = false;
    this.headers = [];
    this.isAborted = false;
  }

  _createClass(ResponseWrapper, [{
    key: "writeHead",
    value: function writeHead(status) {
      this.statusCode = status;
    }
  }, {
    key: "setHeader",
    value: function setHeader(key, value) {
      var _this3 = this;

      if (Array.isArray(value)) {
        value.forEach(function (val) {
          _this3.writeHeader(key, val);
        });
      } else {
        this.writeHeader(key, value);
      }
    }
  }, {
    key: "removeHeader",
    value: function removeHeader() {} // FIXME: not implemented
    // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134

  }, {
    key: "getHeader",
    value: function getHeader() {}
  }, {
    key: "writeStatus",
    value: function writeStatus(status) {
      if (this.isAborted) return;
      this.res.writeStatus(status);
      this.statusWritten = true;
      this.writeBufferedHeaders();
      return this;
    }
  }, {
    key: "writeHeader",
    value: function writeHeader(key, value) {
      if (this.isAborted) return;

      if (key === "Content-Length") {
        // the content length is automatically added by uWebSockets.js
        return;
      }

      if (this.statusWritten) {
        this.res.writeHeader(key, value);
      } else {
        this.headers.push([key, value]);
      }
    }
  }, {
    key: "writeBufferedHeaders",
    value: function writeBufferedHeaders() {
      var _this4 = this;

      this.headers.forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        _this4.res.writeHeader(key, value);
      });
    }
  }, {
    key: "end",
    value: function end(data) {
      var _this5 = this;

      if (this.isAborted) return;
      this.res.cork(function () {
        if (!_this5.statusWritten) {
          // status will be inferred as "200 OK"
          _this5.writeBufferedHeaders();
        }

        _this5.res.end(data);
      });
    }
  }, {
    key: "onData",
    value: function onData(fn) {
      if (this.isAborted) return;
      this.res.onData(fn);
    }
  }, {
    key: "onAborted",
    value: function onAborted(fn) {
      var _this6 = this;

      if (this.isAborted) return;
      this.res.onAborted(function () {
        // Any attempt to use the UWS response object after abort will throw!
        _this6.isAborted = true;
        fn();
      });
    }
  }, {
    key: "cork",
    value: function cork(fn) {
      if (this.isAborted) return;
      this.res.cork(fn);
    }
  }, {
    key: "statusCode",
    set: function set(status) {
      if (!status) {
        return;
      } // FIXME: handle all status codes?


      this.writeStatus(status === 200 ? "200 OK" : "204 No Content");
    }
  }]);

  return ResponseWrapper;
}();
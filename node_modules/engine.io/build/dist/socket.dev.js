"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = void 0;

var events_1 = require("events");

var debug_1 = require("debug");

var timers_1 = require("timers");

var debug = (0, debug_1["default"])("engine:socket");

var Socket =
/*#__PURE__*/
function (_events_1$EventEmitte) {
  _inherits(Socket, _events_1$EventEmitte);

  _createClass(Socket, [{
    key: "readyState",
    get: function get() {
      return this._readyState;
    },
    set: function set(state) {
      debug("readyState updated from %s to %s", this._readyState, state);
      this._readyState = state;
    }
  }]);

  function Socket(id, server, transport, req, protocol) {
    var _this;

    _classCallCheck(this, Socket);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Socket).call(this));
    /**
     * The current state of the socket.
     */

    _this._readyState = "opening";
    /* private */

    _this.upgrading = false;
    /* private */

    _this.upgraded = false;
    _this.writeBuffer = [];
    _this.packetsFn = [];
    _this.sentCallbackFn = [];
    _this.cleanupFn = [];
    _this.id = id;
    _this.server = server;
    _this.request = req;
    _this.protocol = protocol; // Cache IP since it might not be in the req later

    if (req) {
      if (req.websocket && req.websocket._socket) {
        _this.remoteAddress = req.websocket._socket.remoteAddress;
      } else {
        _this.remoteAddress = req.connection.remoteAddress;
      }
    } else {// TODO there is currently no way to get the IP address of the client when it connects with WebTransport
      //  see https://github.com/fails-components/webtransport/issues/114
    }

    _this.pingTimeoutTimer = null;
    _this.pingIntervalTimer = null;

    _this.setTransport(transport);

    _this.onOpen();

    return _this;
  }
  /**
   * Called upon transport considered open.
   *
   * @private
   */


  _createClass(Socket, [{
    key: "onOpen",
    value: function onOpen() {
      this.readyState = "open"; // sends an `open` packet

      this.transport.sid = this.id;
      this.sendPacket("open", JSON.stringify({
        sid: this.id,
        upgrades: this.getAvailableUpgrades(),
        pingInterval: this.server.opts.pingInterval,
        pingTimeout: this.server.opts.pingTimeout,
        maxPayload: this.server.opts.maxHttpBufferSize
      }));

      if (this.server.opts.initialPacket) {
        this.sendPacket("message", this.server.opts.initialPacket);
      }

      this.emit("open");

      if (this.protocol === 3) {
        // in protocol v3, the client sends a ping, and the server answers with a pong
        this.resetPingTimeout();
      } else {
        // in protocol v4, the server sends a ping, and the client answers with a pong
        this.schedulePing();
      }
    }
    /**
     * Called upon transport packet.
     *
     * @param {Object} packet
     * @private
     */

  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      if ("open" !== this.readyState) {
        return debug("packet received with closed socket");
      } // export packet event


      debug("received packet ".concat(packet.type));
      this.emit("packet", packet);

      switch (packet.type) {
        case "ping":
          if (this.transport.protocol !== 3) {
            this.onError(new Error("invalid heartbeat direction"));
            return;
          }

          debug("got ping");
          this.pingTimeoutTimer.refresh();
          this.sendPacket("pong");
          this.emit("heartbeat");
          break;

        case "pong":
          if (this.transport.protocol === 3) {
            this.onError(new Error("invalid heartbeat direction"));
            return;
          }

          debug("got pong");
          (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
          this.pingIntervalTimer.refresh();
          this.emit("heartbeat");
          break;

        case "error":
          this.onClose("parse error");
          break;

        case "message":
          this.emit("data", packet.data);
          this.emit("message", packet.data);
          break;
      }
    }
    /**
     * Called upon transport error.
     *
     * @param {Error} err - error object
     * @private
     */

  }, {
    key: "onError",
    value: function onError(err) {
      debug("transport error");
      this.onClose("transport error", err);
    }
    /**
     * Pings client every `this.pingInterval` and expects response
     * within `this.pingTimeout` or closes connection.
     *
     * @private
     */

  }, {
    key: "schedulePing",
    value: function schedulePing() {
      var _this2 = this;

      this.pingIntervalTimer = (0, timers_1.setTimeout)(function () {
        debug("writing ping packet - expecting pong within %sms", _this2.server.opts.pingTimeout);

        _this2.sendPacket("ping");

        _this2.resetPingTimeout();
      }, this.server.opts.pingInterval);
    }
    /**
     * Resets ping timeout.
     *
     * @private
     */

  }, {
    key: "resetPingTimeout",
    value: function resetPingTimeout() {
      var _this3 = this;

      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
      this.pingTimeoutTimer = (0, timers_1.setTimeout)(function () {
        if (_this3.readyState === "closed") return;

        _this3.onClose("ping timeout");
      }, this.protocol === 3 ? this.server.opts.pingInterval + this.server.opts.pingTimeout : this.server.opts.pingTimeout);
    }
    /**
     * Attaches handlers for the given transport.
     *
     * @param {Transport} transport
     * @private
     */

  }, {
    key: "setTransport",
    value: function setTransport(transport) {
      var _this4 = this;

      var onError = this.onError.bind(this);

      var onReady = function onReady() {
        return _this4.flush();
      };

      var onPacket = this.onPacket.bind(this);
      var onDrain = this.onDrain.bind(this);
      var onClose = this.onClose.bind(this, "transport close");
      this.transport = transport;
      this.transport.once("error", onError);
      this.transport.on("ready", onReady);
      this.transport.on("packet", onPacket);
      this.transport.on("drain", onDrain);
      this.transport.once("close", onClose);
      this.cleanupFn.push(function () {
        transport.removeListener("error", onError);
        transport.removeListener("ready", onReady);
        transport.removeListener("packet", onPacket);
        transport.removeListener("drain", onDrain);
        transport.removeListener("close", onClose);
      });
    }
    /**
     * Upon transport "drain" event
     *
     * @private
     */

  }, {
    key: "onDrain",
    value: function onDrain() {
      if (this.sentCallbackFn.length > 0) {
        debug("executing batch send callback");
        var seqFn = this.sentCallbackFn.shift();

        if (seqFn) {
          for (var i = 0; i < seqFn.length; i++) {
            seqFn[i](this.transport);
          }
        }
      }
    }
    /**
     * Upgrades socket to the given transport
     *
     * @param {Transport} transport
     * @private
     */

    /* private */

  }, {
    key: "_maybeUpgrade",
    value: function _maybeUpgrade(transport) {
      var _this5 = this;

      debug('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
      this.upgrading = true; // set transport upgrade timer

      var upgradeTimeoutTimer = (0, timers_1.setTimeout)(function () {
        debug("client did not complete upgrade - closing transport");
        cleanup();

        if ("open" === transport.readyState) {
          transport.close();
        }
      }, this.server.opts.upgradeTimeout);
      var checkIntervalTimer;

      var onPacket = function onPacket(packet) {
        if ("ping" === packet.type && "probe" === packet.data) {
          debug("got probe ping packet, sending pong");
          transport.send([{
            type: "pong",
            data: "probe"
          }]);

          _this5.emit("upgrading", transport);

          clearInterval(checkIntervalTimer);
          checkIntervalTimer = setInterval(check, 100);
        } else if ("upgrade" === packet.type && _this5.readyState !== "closed") {
          debug("got upgrade packet - upgrading");
          cleanup();

          _this5.transport.discard();

          _this5.upgraded = true;

          _this5.clearTransport();

          _this5.setTransport(transport);

          _this5.emit("upgrade", transport);

          _this5.flush();

          if (_this5.readyState === "closing") {
            transport.close(function () {
              _this5.onClose("forced close");
            });
          }
        } else {
          cleanup();
          transport.close();
        }
      }; // we force a polling cycle to ensure a fast upgrade


      var check = function check() {
        if ("polling" === _this5.transport.name && _this5.transport.writable) {
          debug("writing a noop packet to polling for fast upgrade");

          _this5.transport.send([{
            type: "noop"
          }]);
        }
      };

      var cleanup = function cleanup() {
        _this5.upgrading = false;
        clearInterval(checkIntervalTimer);
        (0, timers_1.clearTimeout)(upgradeTimeoutTimer);
        transport.removeListener("packet", onPacket);
        transport.removeListener("close", onTransportClose);
        transport.removeListener("error", onError);

        _this5.removeListener("close", onClose);
      };

      var onError = function onError(err) {
        debug("client did not complete upgrade - %s", err);
        cleanup();
        transport.close();
        transport = null;
      };

      var onTransportClose = function onTransportClose() {
        onError("transport closed");
      };

      var onClose = function onClose() {
        onError("socket closed");
      };

      transport.on("packet", onPacket);
      transport.once("close", onTransportClose);
      transport.once("error", onError);
      this.once("close", onClose);
    }
    /**
     * Clears listeners and timers associated with current transport.
     *
     * @private
     */

  }, {
    key: "clearTransport",
    value: function clearTransport() {
      var cleanup;
      var toCleanUp = this.cleanupFn.length;

      for (var i = 0; i < toCleanUp; i++) {
        cleanup = this.cleanupFn.shift();
        cleanup();
      } // silence further transport errors and prevent uncaught exceptions


      this.transport.on("error", function () {
        debug("error triggered by discarded transport");
      }); // ensure transport won't stay open

      this.transport.close();
      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
    }
    /**
     * Called upon transport considered closed.
     * Possible reasons: `ping timeout`, `client error`, `parse error`,
     * `transport error`, `server close`, `transport close`
     */

  }, {
    key: "onClose",
    value: function onClose(reason, description) {
      var _this6 = this;

      if ("closed" !== this.readyState) {
        this.readyState = "closed"; // clear timers

        (0, timers_1.clearTimeout)(this.pingIntervalTimer);
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer); // clean writeBuffer in next tick, so developers can still
        // grab the writeBuffer on 'close' event

        process.nextTick(function () {
          _this6.writeBuffer = [];
        });
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.clearTransport();
        this.emit("close", reason, description);
      }
    }
    /**
     * Sends a message packet.
     *
     * @param {Object} data
     * @param {Object} options
     * @param {Function} callback
     * @return {Socket} for chaining
     */

  }, {
    key: "send",
    value: function send(data, options, callback) {
      this.sendPacket("message", data, options, callback);
      return this;
    }
    /**
     * Alias of {@link send}.
     *
     * @param data
     * @param options
     * @param callback
     */

  }, {
    key: "write",
    value: function write(data, options, callback) {
      this.sendPacket("message", data, options, callback);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type - packet type
     * @param {String} data
     * @param {Object} options
     * @param {Function} callback
     *
     * @private
     */

  }, {
    key: "sendPacket",
    value: function sendPacket(type, data) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : undefined;

      if ("function" === typeof options) {
        callback = options;
        options = {};
      }

      if ("closing" !== this.readyState && "closed" !== this.readyState) {
        debug('sending packet "%s" (%s)', type, data); // compression is enabled by default

        options.compress = options.compress !== false;
        var packet = {
          type: type,
          options: options
        };
        if (data) packet.data = data; // exports packetCreate event

        this.emit("packetCreate", packet);
        this.writeBuffer.push(packet); // add send callback to object, if defined

        if ("function" === typeof callback) this.packetsFn.push(callback);
        this.flush();
      }
    }
    /**
     * Attempts to flush the packets buffer.
     *
     * @private
     */

  }, {
    key: "flush",
    value: function flush() {
      if ("closed" !== this.readyState && this.transport.writable && this.writeBuffer.length) {
        debug("flushing buffer to transport");
        this.emit("flush", this.writeBuffer);
        this.server.emit("flush", this, this.writeBuffer);
        var wbuf = this.writeBuffer;
        this.writeBuffer = [];

        if (this.packetsFn.length) {
          this.sentCallbackFn.push(this.packetsFn);
          this.packetsFn = [];
        } else {
          this.sentCallbackFn.push(null);
        }

        this.transport.send(wbuf);
        this.emit("drain");
        this.server.emit("drain", this);
      }
    }
    /**
     * Get available upgrades for this socket.
     *
     * @private
     */

  }, {
    key: "getAvailableUpgrades",
    value: function getAvailableUpgrades() {
      var availableUpgrades = [];
      var allUpgrades = this.server.upgrades(this.transport.name);

      for (var i = 0; i < allUpgrades.length; ++i) {
        var upg = allUpgrades[i];

        if (this.server.opts.transports.indexOf(upg) !== -1) {
          availableUpgrades.push(upg);
        }
      }

      return availableUpgrades;
    }
    /**
     * Closes the socket and underlying transport.
     *
     * @param {Boolean} discard - optional, discard the transport
     * @return {Socket} for chaining
     */

  }, {
    key: "close",
    value: function close(discard) {
      var _this7 = this;

      if (discard && (this.readyState === "open" || this.readyState === "closing")) {
        return this.closeTransport(discard);
      }

      if ("open" !== this.readyState) return;
      this.readyState = "closing";

      if (this.writeBuffer.length) {
        debug("there are %d remaining packets in the buffer, waiting for the 'drain' event", this.writeBuffer.length);
        this.once("drain", function () {
          debug("all packets have been sent, closing the transport");

          _this7.closeTransport(discard);
        });
        return;
      }

      debug("the buffer is empty, closing the transport right away");
      this.closeTransport(discard);
    }
    /**
     * Closes the underlying transport.
     *
     * @param {Boolean} discard
     * @private
     */

  }, {
    key: "closeTransport",
    value: function closeTransport(discard) {
      debug("closing the transport (discard? %s)", !!discard);
      if (discard) this.transport.discard();
      this.transport.close(this.onClose.bind(this, "forced close"));
    }
  }]);

  return Socket;
}(events_1.EventEmitter);

exports.Socket = Socket;
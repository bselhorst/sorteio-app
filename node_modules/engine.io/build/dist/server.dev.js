"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Server = exports.BaseServer = void 0;

var qs = require("querystring");

var url_1 = require("url");

var base64id = require("base64id");

var transports_1 = require("./transports");

var events_1 = require("events");

var socket_1 = require("./socket");

var debug_1 = require("debug");

var cookie_1 = require("cookie");

var ws_1 = require("ws");

var webtransport_1 = require("./transports/webtransport");

var engine_io_parser_1 = require("engine.io-parser");

var debug = (0, debug_1["default"])("engine");
var kResponseHeaders = Symbol("responseHeaders");

function parseSessionId(data) {
  try {
    var parsed = JSON.parse(data);

    if (typeof parsed.sid === "string") {
      return parsed.sid;
    }
  } catch (e) {}
}

var BaseServer =
/*#__PURE__*/
function (_events_1$EventEmitte) {
  _inherits(BaseServer, _events_1$EventEmitte);

  /**
   * Server constructor.
   *
   * @param {Object} opts - options
   */
  function BaseServer() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, BaseServer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseServer).call(this));
    _this.middlewares = [];
    _this.clients = {};
    _this.clientsCount = 0;
    _this.opts = Object.assign({
      wsEngine: ws_1.Server,
      pingTimeout: 20000,
      pingInterval: 25000,
      upgradeTimeout: 10000,
      maxHttpBufferSize: 1e6,
      transports: ["polling", "websocket"],
      // WebTransport is disabled by default
      allowUpgrades: true,
      httpCompression: {
        threshold: 1024
      },
      cors: false,
      allowEIO3: false
    }, opts);

    if (opts.cookie) {
      _this.opts.cookie = Object.assign({
        name: "io",
        path: "/",
        // @ts-ignore
        httpOnly: opts.cookie.path !== false,
        sameSite: "lax"
      }, opts.cookie);
    }

    if (_this.opts.cors) {
      _this.use(require("cors")(_this.opts.cors));
    }

    if (opts.perMessageDeflate) {
      _this.opts.perMessageDeflate = Object.assign({
        threshold: 1024
      }, opts.perMessageDeflate);
    }

    _this.init();

    return _this;
  }
  /**
   * Compute the pathname of the requests that are handled by the server
   * @param options
   * @protected
   */


  _createClass(BaseServer, [{
    key: "_computePath",
    value: function _computePath(options) {
      var path = (options.path || "/engine.io").replace(/\/$/, "");

      if (options.addTrailingSlash !== false) {
        // normalize path
        path += "/";
      }

      return path;
    }
    /**
     * Returns a list of available transports for upgrade given a certain transport.
     *
     * @return {Array}
     */

  }, {
    key: "upgrades",
    value: function upgrades(transport) {
      if (!this.opts.allowUpgrades) return [];
      return transports_1["default"][transport].upgradesTo || [];
    }
    /**
     * Verifies a request.
     *
     * @param {EngineRequest} req
     * @param upgrade - whether it's an upgrade request
     * @param fn
     * @protected
     */

  }, {
    key: "verify",
    value: function verify(req, upgrade, fn) {
      // transport check
      var transport = req._query.transport; // WebTransport does not go through the verify() method, see the onWebTransportSession() method

      if (!~this.opts.transports.indexOf(transport) || transport === "webtransport") {
        debug('unknown transport "%s"', transport);
        return fn(Server.errors.UNKNOWN_TRANSPORT, {
          transport: transport
        });
      } // 'Origin' header check


      var isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);

      if (isOriginInvalid) {
        var origin = req.headers.origin;
        req.headers.origin = null;
        debug("origin header invalid");
        return fn(Server.errors.BAD_REQUEST, {
          name: "INVALID_ORIGIN",
          origin: origin
        });
      } // sid check


      var sid = req._query.sid;

      if (sid) {
        if (!this.clients.hasOwnProperty(sid)) {
          debug('unknown sid "%s"', sid);
          return fn(Server.errors.UNKNOWN_SID, {
            sid: sid
          });
        }

        var previousTransport = this.clients[sid].transport.name;

        if (!upgrade && previousTransport !== transport) {
          debug("bad request: unexpected transport without upgrade");
          return fn(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_MISMATCH",
            transport: transport,
            previousTransport: previousTransport
          });
        }
      } else {
        // handshake is GET only
        if ("GET" !== req.method) {
          return fn(Server.errors.BAD_HANDSHAKE_METHOD, {
            method: req.method
          });
        }

        if (transport === "websocket" && !upgrade) {
          debug("invalid transport upgrade");
          return fn(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_HANDSHAKE_ERROR"
          });
        }

        if (!this.opts.allowRequest) return fn();
        return this.opts.allowRequest(req, function (message, success) {
          if (!success) {
            return fn(Server.errors.FORBIDDEN, {
              message: message
            });
          }

          fn();
        });
      }

      fn();
    }
    /**
     * Adds a new middleware.
     *
     * @example
     * import helmet from "helmet";
     *
     * engine.use(helmet());
     *
     * @param fn
     */

  }, {
    key: "use",
    value: function use(fn) {
      this.middlewares.push(fn);
    }
    /**
     * Apply the middlewares to the request.
     *
     * @param req
     * @param res
     * @param callback
     * @protected
     */

  }, {
    key: "_applyMiddlewares",
    value: function _applyMiddlewares(req, res, callback) {
      var _this2 = this;

      if (this.middlewares.length === 0) {
        debug("no middleware to apply, skipping");
        return callback();
      }

      var apply = function apply(i) {
        debug("applying middleware nÂ°%d", i + 1);

        _this2.middlewares[i](req, res, function (err) {
          if (err) {
            return callback(err);
          }

          if (i + 1 < _this2.middlewares.length) {
            apply(i + 1);
          } else {
            callback();
          }
        });
      };

      apply(0);
    }
    /**
     * Closes all clients.
     */

  }, {
    key: "close",
    value: function close() {
      debug("closing all open clients");

      for (var i in this.clients) {
        if (this.clients.hasOwnProperty(i)) {
          this.clients[i].close(true);
        }
      }

      this.cleanup();
      return this;
    }
    /**
     * generate a socket id.
     * Overwrite this method to generate your custom socket id
     *
     * @param {IncomingMessage} req - the request object
     */

  }, {
    key: "generateId",
    value: function generateId(req) {
      return base64id.generateId();
    }
    /**
     * Handshakes a new client.
     *
     * @param {String} transportName
     * @param {Object} req - the request object
     * @param {Function} closeConnection
     *
     * @protected
     */

  }, {
    key: "handshake",
    value: function handshake(transportName, req, closeConnection) {
      var _this3 = this;

      var protocol, id, transport, socket;
      return regeneratorRuntime.async(function handshake$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              protocol = req._query.EIO === "4" ? 4 : 3; // 3rd revision by default

              if (!(protocol === 3 && !this.opts.allowEIO3)) {
                _context.next = 6;
                break;
              }

              debug("unsupported protocol version");
              this.emit("connection_error", {
                req: req,
                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,
                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],
                context: {
                  protocol: protocol
                }
              });
              closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);
              return _context.abrupt("return");

            case 6:
              _context.prev = 6;
              _context.next = 9;
              return regeneratorRuntime.awrap(this.generateId(req));

            case 9:
              id = _context.sent;
              _context.next = 18;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](6);
              debug("error while generating an id");
              this.emit("connection_error", {
                req: req,
                code: Server.errors.BAD_REQUEST,
                message: Server.errorMessages[Server.errors.BAD_REQUEST],
                context: {
                  name: "ID_GENERATION_ERROR",
                  error: _context.t0
                }
              });
              closeConnection(Server.errors.BAD_REQUEST);
              return _context.abrupt("return");

            case 18:
              debug('handshaking client "%s"', id);
              _context.prev = 19;
              transport = this.createTransport(transportName, req);

              if ("polling" === transportName) {
                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
                transport.httpCompression = this.opts.httpCompression;
              } else if ("websocket" === transportName) {
                transport.perMessageDeflate = this.opts.perMessageDeflate;
              }

              _context.next = 30;
              break;

            case 24:
              _context.prev = 24;
              _context.t1 = _context["catch"](19);
              debug('error handshaking to transport "%s"', transportName);
              this.emit("connection_error", {
                req: req,
                code: Server.errors.BAD_REQUEST,
                message: Server.errorMessages[Server.errors.BAD_REQUEST],
                context: {
                  name: "TRANSPORT_HANDSHAKE_ERROR",
                  error: _context.t1
                }
              });
              closeConnection(Server.errors.BAD_REQUEST);
              return _context.abrupt("return");

            case 30:
              socket = new socket_1.Socket(id, this, transport, req, protocol);
              transport.on("headers", function (headers, req) {
                var isInitialRequest = !req._query.sid;

                if (isInitialRequest) {
                  if (_this3.opts.cookie) {
                    headers["Set-Cookie"] = [// @ts-ignore
                    (0, cookie_1.serialize)(_this3.opts.cookie.name, id, _this3.opts.cookie)];
                  }

                  _this3.emit("initial_headers", headers, req);
                }

                _this3.emit("headers", headers, req);
              });
              transport.onRequest(req);
              this.clients[id] = socket;
              this.clientsCount++;
              socket.once("close", function () {
                delete _this3.clients[id];
                _this3.clientsCount--;
              });
              this.emit("connection", socket);
              return _context.abrupt("return", transport);

            case 38:
            case "end":
              return _context.stop();
          }
        }
      }, null, this, [[6, 12], [19, 24]]);
    }
  }, {
    key: "onWebTransportSession",
    value: function onWebTransportSession(session) {
      var _this4 = this;

      var timeout, streamReader, result, stream, transformStream, reader, _ref, value, done, transport, id, socket, sid, client, _transport;

      return regeneratorRuntime.async(function onWebTransportSession$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              timeout = setTimeout(function () {
                debug("the client failed to establish a bidirectional stream in the given period");
                session.close();
              }, this.opts.upgradeTimeout);
              streamReader = session.incomingBidirectionalStreams.getReader();
              _context2.next = 4;
              return regeneratorRuntime.awrap(streamReader.read());

            case 4:
              result = _context2.sent;

              if (!result.done) {
                _context2.next = 8;
                break;
              }

              debug("session is closed");
              return _context2.abrupt("return");

            case 8:
              stream = result.value;
              transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(this.opts.maxHttpBufferSize, "nodebuffer");
              reader = stream.readable.pipeThrough(transformStream).getReader(); // reading the first packet of the stream

              _context2.next = 13;
              return regeneratorRuntime.awrap(reader.read());

            case 13:
              _ref = _context2.sent;
              value = _ref.value;
              done = _ref.done;

              if (!done) {
                _context2.next = 19;
                break;
              }

              debug("stream is closed");
              return _context2.abrupt("return");

            case 19:
              clearTimeout(timeout);

              if (!(value.type !== "open")) {
                _context2.next = 23;
                break;
              }

              debug("invalid WebTransport handshake");
              return _context2.abrupt("return", session.close());

            case 23:
              if (!(value.data === undefined)) {
                _context2.next = 33;
                break;
              }

              transport = new webtransport_1.WebTransport(session, stream, reader); // note: we cannot use "this.generateId()", because there is no "req" argument

              id = base64id.generateId();
              debug('handshaking client "%s" (WebTransport)', id);
              socket = new socket_1.Socket(id, this, transport, null, 4);
              this.clients[id] = socket;
              this.clientsCount++;
              socket.once("close", function () {
                delete _this4.clients[id];
                _this4.clientsCount--;
              });
              this.emit("connection", socket);
              return _context2.abrupt("return");

            case 33:
              sid = parseSessionId(value.data);

              if (sid) {
                _context2.next = 37;
                break;
              }

              debug("invalid WebTransport handshake");
              return _context2.abrupt("return", session.close());

            case 37:
              client = this.clients[sid];

              if (!client) {
                debug("upgrade attempt for closed client");
                session.close();
              } else if (client.upgrading) {
                debug("transport has already been trying to upgrade");
                session.close();
              } else if (client.upgraded) {
                debug("transport had already been upgraded");
                session.close();
              } else {
                debug("upgrading existing transport");
                _transport = new webtransport_1.WebTransport(session, stream, reader);

                client._maybeUpgrade(_transport);
              }

            case 39:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }]);

  return BaseServer;
}(events_1.EventEmitter);

exports.BaseServer = BaseServer;
/**
 * Protocol errors mappings.
 */

BaseServer.errors = {
  UNKNOWN_TRANSPORT: 0,
  UNKNOWN_SID: 1,
  BAD_HANDSHAKE_METHOD: 2,
  BAD_REQUEST: 3,
  FORBIDDEN: 4,
  UNSUPPORTED_PROTOCOL_VERSION: 5
};
BaseServer.errorMessages = {
  0: "Transport unknown",
  1: "Session ID unknown",
  2: "Bad handshake method",
  3: "Bad request",
  4: "Forbidden",
  5: "Unsupported protocol version"
};
/**
 * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade
 * request.
 *
 * @see https://nodejs.org/api/http.html#class-httpserverresponse
 */

var WebSocketResponse =
/*#__PURE__*/
function () {
  function WebSocketResponse(req, socket) {
    _classCallCheck(this, WebSocketResponse);

    this.req = req;
    this.socket = socket; // temporarily store the response headers on the req object (see the "headers" event)

    req[kResponseHeaders] = {};
  }

  _createClass(WebSocketResponse, [{
    key: "setHeader",
    value: function setHeader(name, value) {
      this.req[kResponseHeaders][name] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(name) {
      return this.req[kResponseHeaders][name];
    }
  }, {
    key: "removeHeader",
    value: function removeHeader(name) {
      delete this.req[kResponseHeaders][name];
    }
  }, {
    key: "write",
    value: function write() {}
  }, {
    key: "writeHead",
    value: function writeHead() {}
  }, {
    key: "end",
    value: function end() {
      // we could return a proper error code, but the WebSocket client will emit an "error" event anyway.
      this.socket.destroy();
    }
  }]);

  return WebSocketResponse;
}();
/**
 * An Engine.IO server based on Node.js built-in HTTP server and the `ws` package for WebSocket connections.
 */


var Server =
/*#__PURE__*/
function (_BaseServer) {
  _inherits(Server, _BaseServer);

  function Server() {
    _classCallCheck(this, Server);

    return _possibleConstructorReturn(this, _getPrototypeOf(Server).apply(this, arguments));
  }

  _createClass(Server, [{
    key: "init",

    /**
     * Initialize websocket server
     *
     * @protected
     */
    value: function init() {
      var _this5 = this;

      if (!~this.opts.transports.indexOf("websocket")) return;
      if (this.ws) this.ws.close();
      this.ws = new this.opts.wsEngine({
        noServer: true,
        clientTracking: false,
        perMessageDeflate: this.opts.perMessageDeflate,
        maxPayload: this.opts.maxHttpBufferSize
      });

      if (typeof this.ws.on === "function") {
        this.ws.on("headers", function (headersArray, req) {
          // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)
          // we could also try to parse the array and then sync the values, but that will be error-prone
          var additionalHeaders = req[kResponseHeaders] || {};
          delete req[kResponseHeaders];
          var isInitialRequest = !req._query.sid;

          if (isInitialRequest) {
            _this5.emit("initial_headers", additionalHeaders, req);
          }

          _this5.emit("headers", additionalHeaders, req);

          debug("writing headers: %j", additionalHeaders);
          Object.keys(additionalHeaders).forEach(function (key) {
            headersArray.push("".concat(key, ": ").concat(additionalHeaders[key]));
          });
        });
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this.ws) {
        debug("closing webSocketServer");
        this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again
      }
    }
    /**
     * Prepares a request by processing the query string.
     *
     * @private
     */

  }, {
    key: "prepare",
    value: function prepare(req) {
      // try to leverage pre-existing `req._query` (e.g: from connect)
      if (!req._query) {
        req._query = ~req.url.indexOf("?") ? qs.parse((0, url_1.parse)(req.url).query) : {};
      }
    }
  }, {
    key: "createTransport",
    value: function createTransport(transportName, req) {
      return new transports_1["default"][transportName](req);
    }
    /**
     * Handles an Engine.IO HTTP request.
     *
     * @param {EngineRequest} req
     * @param {ServerResponse} res
     */

  }, {
    key: "handleRequest",
    value: function handleRequest(req, res) {
      var _this6 = this;

      debug('handling "%s" http request "%s"', req.method, req.url);
      this.prepare(req);
      req.res = res;

      var callback = function callback(errorCode, errorContext) {
        if (errorCode !== undefined) {
          _this6.emit("connection_error", {
            req: req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });

          abortRequest(res, errorCode, errorContext);
          return;
        }

        if (req._query.sid) {
          debug("setting new request for existing client");

          _this6.clients[req._query.sid].transport.onRequest(req);
        } else {
          var closeConnection = function closeConnection(errorCode, errorContext) {
            return abortRequest(res, errorCode, errorContext);
          };

          _this6.handshake(req._query.transport, req, closeConnection);
        }
      };

      this._applyMiddlewares(req, res, function (err) {
        if (err) {
          callback(Server.errors.BAD_REQUEST, {
            name: "MIDDLEWARE_FAILURE"
          });
        } else {
          _this6.verify(req, false, callback);
        }
      });
    }
    /**
     * Handles an Engine.IO HTTP Upgrade.
     */

  }, {
    key: "handleUpgrade",
    value: function handleUpgrade(req, socket, upgradeHead) {
      var _this7 = this;

      this.prepare(req);
      var res = new WebSocketResponse(req, socket);

      var callback = function callback(errorCode, errorContext) {
        if (errorCode !== undefined) {
          _this7.emit("connection_error", {
            req: req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });

          abortUpgrade(socket, errorCode, errorContext);
          return;
        }

        var head = Buffer.from(upgradeHead);
        upgradeHead = null; // some middlewares (like express-session) wait for the writeHead() call to flush their headers
        // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244

        res.writeHead(); // delegate to ws

        _this7.ws.handleUpgrade(req, socket, head, function (websocket) {
          _this7.onWebSocket(req, socket, websocket);
        });
      };

      this._applyMiddlewares(req, res, function (err) {
        if (err) {
          callback(Server.errors.BAD_REQUEST, {
            name: "MIDDLEWARE_FAILURE"
          });
        } else {
          _this7.verify(req, true, callback);
        }
      });
    }
    /**
     * Called upon a ws.io connection.
     *
     * @param {ws.Socket} websocket
     * @private
     */

  }, {
    key: "onWebSocket",
    value: function onWebSocket(req, socket, websocket) {
      websocket.on("error", onUpgradeError);

      if (transports_1["default"][req._query.transport] !== undefined && !transports_1["default"][req._query.transport].prototype.handlesUpgrades) {
        debug("transport doesnt handle upgraded requests");
        websocket.close();
        return;
      } // get client id


      var id = req._query.sid; // keep a reference to the ws.Socket

      req.websocket = websocket;

      if (id) {
        var client = this.clients[id];

        if (!client) {
          debug("upgrade attempt for closed client");
          websocket.close();
        } else if (client.upgrading) {
          debug("transport has already been trying to upgrade");
          websocket.close();
        } else if (client.upgraded) {
          debug("transport had already been upgraded");
          websocket.close();
        } else {
          debug("upgrading existing transport"); // transport error handling takes over

          websocket.removeListener("error", onUpgradeError);
          var transport = this.createTransport(req._query.transport, req);
          transport.perMessageDeflate = this.opts.perMessageDeflate;

          client._maybeUpgrade(transport);
        }
      } else {
        var closeConnection = function closeConnection(errorCode, errorContext) {
          return abortUpgrade(socket, errorCode, errorContext);
        };

        this.handshake(req._query.transport, req, closeConnection);
      }

      function onUpgradeError() {
        debug("websocket error before upgrade"); // websocket.close() not needed
      }
    }
    /**
     * Captures upgrade requests for a http.Server.
     *
     * @param {http.Server} server
     * @param {Object} options
     */

  }, {
    key: "attach",
    value: function attach(server) {
      var _this8 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var path = this._computePath(options);

      var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;

      function check(req) {
        // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)
        return path === req.url.slice(0, path.length);
      } // cache and clean up listeners


      var listeners = server.listeners("request").slice(0);
      server.removeAllListeners("request");
      server.on("close", this.close.bind(this));
      server.on("listening", this.init.bind(this)); // add request handler

      server.on("request", function (req, res) {
        if (check(req)) {
          debug('intercepting request for path "%s"', path);

          _this8.handleRequest(req, res);
        } else {
          var i = 0;
          var l = listeners.length;

          for (; i < l; i++) {
            listeners[i].call(server, req, res);
          }
        }
      });

      if (~this.opts.transports.indexOf("websocket")) {
        server.on("upgrade", function (req, socket, head) {
          if (check(req)) {
            _this8.handleUpgrade(req, socket, head);
          } else if (false !== options.destroyUpgrade) {
            // default node behavior is to disconnect when no handlers
            // but by adding a handler, we prevent that
            // and if no eio thing handles the upgrade
            // then the socket needs to die!
            setTimeout(function () {
              // @ts-ignore
              if (socket.writable && socket.bytesWritten <= 0) {
                socket.on("error", function (e) {
                  debug("error while destroying upgrade: %s", e.message);
                });
                return socket.end();
              }
            }, destroyUpgradeTimeout);
          }
        });
      }
    }
  }]);

  return Server;
}(BaseServer);

exports.Server = Server;
/**
 * Close the HTTP long-polling request
 *
 * @param res - the response object
 * @param errorCode - the error code
 * @param errorContext - additional error context
 *
 * @private
 */

function abortRequest(res, errorCode, errorContext) {
  var statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;
  var message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];
  res.writeHead(statusCode, {
    "Content-Type": "application/json"
  });
  res.end(JSON.stringify({
    code: errorCode,
    message: message
  }));
}
/**
 * Close the WebSocket connection
 *
 * @param {net.Socket} socket
 * @param {string} errorCode - the error code
 * @param {object} errorContext - additional error context
 */


function abortUpgrade(socket, errorCode) {
  var errorContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  socket.on("error", function () {
    debug("ignoring error from closed connection");
  });

  if (socket.writable) {
    var message = errorContext.message || Server.errorMessages[errorCode];
    var length = Buffer.byteLength(message);
    socket.write("HTTP/1.1 400 Bad Request\r\n" + "Connection: close\r\n" + "Content-type: text/html\r\n" + "Content-Length: " + length + "\r\n" + "\r\n" + message);
  }

  socket.destroy();
}
/* eslint-disable */

/**
 * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354
 *
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 *
 * checkInvalidHeaderChar() is currently designed to be inlinable by v8,
 * so take care when making changes to the implementation so that the source
 * code size does not exceed v8's default max_inlined_source_size setting.
 **/
// prettier-ignore


var validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255
];

function checkInvalidHeaderChar(val) {
  val += "";
  if (val.length < 1) return false;

  if (!validHdrChars[val.charCodeAt(0)]) {
    debug('invalid header, index 0, char "%s"', val.charCodeAt(0));
    return true;
  }

  if (val.length < 2) return false;

  if (!validHdrChars[val.charCodeAt(1)]) {
    debug('invalid header, index 1, char "%s"', val.charCodeAt(1));
    return true;
  }

  if (val.length < 3) return false;

  if (!validHdrChars[val.charCodeAt(2)]) {
    debug('invalid header, index 2, char "%s"', val.charCodeAt(2));
    return true;
  }

  if (val.length < 4) return false;

  if (!validHdrChars[val.charCodeAt(3)]) {
    debug('invalid header, index 3, char "%s"', val.charCodeAt(3));
    return true;
  }

  for (var i = 4; i < val.length; ++i) {
    if (!validHdrChars[val.charCodeAt(i)]) {
      debug('invalid header, index "%i", char "%s"', i, val.charCodeAt(i));
      return true;
    }
  }

  return false;
}
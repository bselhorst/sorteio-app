'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require('stream'),
    Writable = _require.Writable;

var PerMessageDeflate = require('./permessage-deflate');

var _require2 = require('./constants'),
    BINARY_TYPES = _require2.BINARY_TYPES,
    EMPTY_BUFFER = _require2.EMPTY_BUFFER,
    kStatusCode = _require2.kStatusCode,
    kWebSocket = _require2.kWebSocket;

var _require3 = require('./buffer-util'),
    concat = _require3.concat,
    toArrayBuffer = _require3.toArrayBuffer,
    unmask = _require3.unmask;

var _require4 = require('./validation'),
    isValidStatusCode = _require4.isValidStatusCode,
    isValidUTF8 = _require4.isValidUTF8;

var FastBuffer = Buffer[Symbol.species];
var GET_INFO = 0;
var GET_PAYLOAD_LENGTH_16 = 1;
var GET_PAYLOAD_LENGTH_64 = 2;
var GET_MASK = 3;
var GET_DATA = 4;
var INFLATING = 5;
var DEFER_EVENT = 6;
/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */

var Receiver =
/*#__PURE__*/
function (_Writable) {
  _inherits(Receiver, _Writable);

  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  function Receiver() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Receiver);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Receiver).call(this));
    _this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;
    _this._binaryType = options.binaryType || BINARY_TYPES[0];
    _this._extensions = options.extensions || {};
    _this._isServer = !!options.isServer;
    _this._maxPayload = options.maxPayload | 0;
    _this._skipUTF8Validation = !!options.skipUTF8Validation;
    _this[kWebSocket] = undefined;
    _this._bufferedBytes = 0;
    _this._buffers = [];
    _this._compressed = false;
    _this._payloadLength = 0;
    _this._mask = undefined;
    _this._fragmented = 0;
    _this._masked = false;
    _this._fin = false;
    _this._opcode = 0;
    _this._totalPayloadLength = 0;
    _this._messageLength = 0;
    _this._fragments = [];
    _this._errored = false;
    _this._loop = false;
    _this._state = GET_INFO;
    return _this;
  }
  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */


  _createClass(Receiver, [{
    key: "_write",
    value: function _write(chunk, encoding, cb) {
      if (this._opcode === 0x08 && this._state == GET_INFO) return cb();
      this._bufferedBytes += chunk.length;

      this._buffers.push(chunk);

      this.startLoop(cb);
    }
    /**
     * Consumes `n` bytes from the buffered data.
     *
     * @param {Number} n The number of bytes to consume
     * @return {Buffer} The consumed bytes
     * @private
     */

  }, {
    key: "consume",
    value: function consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length) return this._buffers.shift();

      if (n < this._buffers[0].length) {
        var buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }

      var dst = Buffer.allocUnsafe(n);

      do {
        var _buf = this._buffers[0];
        var offset = dst.length - n;

        if (n >= _buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(_buf.buffer, _buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(_buf.buffer, _buf.byteOffset + n, _buf.length - n);
        }

        n -= _buf.length;
      } while (n > 0);

      return dst;
    }
    /**
     * Starts the parsing loop.
     *
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "startLoop",
    value: function startLoop(cb) {
      this._loop = true;

      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;

          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;

          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;

          case GET_MASK:
            this.getMask();
            break;

          case GET_DATA:
            this.getData(cb);
            break;

          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);

      if (!this._errored) cb();
    }
    /**
     * Reads the first two bytes of a frame.
     *
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "getInfo",
    value: function getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }

      var buf = this.consume(2);

      if ((buf[0] & 0x30) !== 0x00) {
        var error = this.createError(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');
        cb(error);
        return;
      }

      var compressed = (buf[0] & 0x40) === 0x40;

      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        var _error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');

        cb(_error);
        return;
      }

      this._fin = (buf[0] & 0x80) === 0x80;
      this._opcode = buf[0] & 0x0f;
      this._payloadLength = buf[1] & 0x7f;

      if (this._opcode === 0x00) {
        if (compressed) {
          var _error2 = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');

          cb(_error2);
          return;
        }

        if (!this._fragmented) {
          var _error3 = this.createError(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');

          cb(_error3);
          return;
        }

        this._opcode = this._fragmented;
      } else if (this._opcode === 0x01 || this._opcode === 0x02) {
        if (this._fragmented) {
          var _error4 = this.createError(RangeError, "invalid opcode ".concat(this._opcode), true, 1002, 'WS_ERR_INVALID_OPCODE');

          cb(_error4);
          return;
        }

        this._compressed = compressed;
      } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
        if (!this._fin) {
          var _error5 = this.createError(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');

          cb(_error5);
          return;
        }

        if (compressed) {
          var _error6 = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');

          cb(_error6);
          return;
        }

        if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {
          var _error7 = this.createError(RangeError, "invalid payload length ".concat(this._payloadLength), true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');

          cb(_error7);
          return;
        }
      } else {
        var _error8 = this.createError(RangeError, "invalid opcode ".concat(this._opcode), true, 1002, 'WS_ERR_INVALID_OPCODE');

        cb(_error8);
        return;
      }

      if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
      this._masked = (buf[1] & 0x80) === 0x80;

      if (this._isServer) {
        if (!this._masked) {
          var _error9 = this.createError(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');

          cb(_error9);
          return;
        }
      } else if (this._masked) {
        var _error10 = this.createError(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');

        cb(_error10);
        return;
      }

      if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else this.haveLength(cb);
    }
    /**
     * Gets extended payload length (7+16).
     *
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "getPayloadLength16",
    value: function getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }

      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    /**
     * Gets extended payload length (7+64).
     *
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "getPayloadLength64",
    value: function getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }

      var buf = this.consume(8);
      var num = buf.readUInt32BE(0); //
      // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
      // if payload length is greater than this number.
      //

      if (num > Math.pow(2, 53 - 32) - 1) {
        var error = this.createError(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');
        cb(error);
        return;
      }

      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    /**
     * Payload length has been read.
     *
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "haveLength",
    value: function haveLength(cb) {
      if (this._payloadLength && this._opcode < 0x08) {
        this._totalPayloadLength += this._payloadLength;

        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          var error = this.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
          cb(error);
          return;
        }
      }

      if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;
    }
    /**
     * Reads mask bytes.
     *
     * @private
     */

  }, {
    key: "getMask",
    value: function getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }

      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    /**
     * Reads data bytes.
     *
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "getData",
    value: function getData(cb) {
      var data = EMPTY_BUFFER;

      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }

        data = this.consume(this._payloadLength);

        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }

      if (this._opcode > 0x07) {
        this.controlMessage(data, cb);
        return;
      }

      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }

      if (data.length) {
        //
        // This message is not compressed so its length is the sum of the payload
        // length of all fragments.
        //
        this._messageLength = this._totalPayloadLength;

        this._fragments.push(data);
      }

      this.dataMessage(cb);
    }
    /**
     * Decompresses data.
     *
     * @param {Buffer} data Compressed data
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "decompress",
    value: function decompress(data, cb) {
      var _this2 = this;

      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, function (err, buf) {
        if (err) return cb(err);

        if (buf.length) {
          _this2._messageLength += buf.length;

          if (_this2._messageLength > _this2._maxPayload && _this2._maxPayload > 0) {
            var error = _this2.createError(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');

            cb(error);
            return;
          }

          _this2._fragments.push(buf);
        }

        _this2.dataMessage(cb);

        if (_this2._state === GET_INFO) _this2.startLoop(cb);
      });
    }
    /**
     * Handles a data message.
     *
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "dataMessage",
    value: function dataMessage(cb) {
      var _this3 = this;

      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }

      var messageLength = this._messageLength;
      var fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];

      if (this._opcode === 2) {
        var data;

        if (this._binaryType === 'nodebuffer') {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === 'arraybuffer') {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data = fragments;
        }

        if (this._allowSynchronousEvents) {
          this.emit('message', data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(function () {
            _this3.emit('message', data, true);

            _this3._state = GET_INFO;

            _this3.startLoop(cb);
          });
        }
      } else {
        var buf = concat(fragments, messageLength);

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          var error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
          cb(error);
          return;
        }

        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit('message', buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(function () {
            _this3.emit('message', buf, false);

            _this3._state = GET_INFO;

            _this3.startLoop(cb);
          });
        }
      }
    }
    /**
     * Handles a control message.
     *
     * @param {Buffer} data Data to handle
     * @return {(Error|RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "controlMessage",
    value: function controlMessage(data, cb) {
      var _this4 = this;

      if (this._opcode === 0x08) {
        if (data.length === 0) {
          this._loop = false;
          this.emit('conclude', 1005, EMPTY_BUFFER);
          this.end();
        } else {
          var code = data.readUInt16BE(0);

          if (!isValidStatusCode(code)) {
            var error = this.createError(RangeError, "invalid status code ".concat(code), true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');
            cb(error);
            return;
          }

          var buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);

          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            var _error11 = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');

            cb(_error11);
            return;
          }

          this._loop = false;
          this.emit('conclude', code, buf);
          this.end();
        }

        this._state = GET_INFO;
        return;
      }

      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(function () {
          _this4.emit(_this4._opcode === 0x09 ? 'ping' : 'pong', data);

          _this4._state = GET_INFO;

          _this4.startLoop(cb);
        });
      }
    }
    /**
     * Builds an error object.
     *
     * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
     * @param {String} message The error message
     * @param {Boolean} prefix Specifies whether or not to add a default prefix to
     *     `message`
     * @param {Number} statusCode The status code
     * @param {String} errorCode The exposed error code
     * @return {(Error|RangeError)} The error
     * @private
     */

  }, {
    key: "createError",
    value: function createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      var err = new ErrorCtor(prefix ? "Invalid WebSocket frame: ".concat(message) : message);
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }]);

  return Receiver;
}(Writable);

module.exports = Receiver;